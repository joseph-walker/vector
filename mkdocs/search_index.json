{
    "docs": [
        {
            "location": "/", 
            "text": "Vector / Core\n\n\nPurpose\n\n\nVector gives your functions superpowers.\nIt lets you autoload your functions with Composer without having to mess with autload files.\nIt allows you to automatically curry your userland functions with zero effort on your part.\nIt provides built-in memoization for abstracting away time-consuming pure operations.\nIt gives you useful helpers for composing simple functions into more complex ones and gives you the building blocks you need to make data manipulation easier than ever, all while maintaining a simple and declarative module loading system so your dependencies are always clear and concise.\n\n\nPHP Version Support\n\n\n\n\n5.6 +\n\n\n\n\nShow Me Some Code\n\n\nAutoloading Functions? A snap.\n\n\nuse Vector\\Lib\\ArrayList;\n\n\n\n\nCurrying? Completely free.\n\n\n$addOne = ArrayList::map(function($a) { return $a + 1; });\n$addOne([1, 2, 3]); // [2, 3, 4]\n\n\n\n\nMemoization? Batteries included.\n\n\nClass MyFunctions extends Module {\n    protected $memoize = ['myFunction'];\n}\n\n\n\n\nComposition? No problem.\n\n\n$addSix = Lambda::compose(Math::add(4), Math::add(2));\n$addSix(4); // 10;", 
            "title": "Introduction"
        }, 
        {
            "location": "/#vector-core", 
            "text": "", 
            "title": "Vector / Core"
        }, 
        {
            "location": "/#purpose", 
            "text": "Vector gives your functions superpowers.\nIt lets you autoload your functions with Composer without having to mess with autload files.\nIt allows you to automatically curry your userland functions with zero effort on your part.\nIt provides built-in memoization for abstracting away time-consuming pure operations.\nIt gives you useful helpers for composing simple functions into more complex ones and gives you the building blocks you need to make data manipulation easier than ever, all while maintaining a simple and declarative module loading system so your dependencies are always clear and concise.", 
            "title": "Purpose"
        }, 
        {
            "location": "/#php-version-support", 
            "text": "5.6 +", 
            "title": "PHP Version Support"
        }, 
        {
            "location": "/#show-me-some-code", 
            "text": "Autoloading Functions? A snap.  use Vector\\Lib\\ArrayList;  Currying? Completely free.  $addOne = ArrayList::map(function($a) { return $a + 1; });\n$addOne([1, 2, 3]); // [2, 3, 4]  Memoization? Batteries included.  Class MyFunctions extends Module {\n    protected $memoize = ['myFunction'];\n}  Composition? No problem.  $addSix = Lambda::compose(Math::add(4), Math::add(2));\n$addSix(4); // 10;", 
            "title": "Show Me Some Code"
        }, 
        {
            "location": "/user-guide/basics/", 
            "text": "Functional Basics\n\n\nFirst of all, what is functional programming?\n\n\n\n\nIn computer science, functional programming is a programming paradigm that treats computation\nas the evaluation of mathematical functions and avoids changing-state and mutable data.\n\n\n\n\nVector is a functional programming library that follows this credo and implements helpers and utilities\nthat allow you to do the same in your own code.\n\n\nBefore we get started, here's some things to know:\n\n\nFunction Declaration vs. Function Expression\n\n\nYou're probably very familiar with functions in PHP. But what you might not know is that there are\nmultiple ways to declare functions in PHP. The first is a declaration, where a function name is placed\ninto a function table keyed to its name and accessible globally (so long as it's loaded). The second method is\na function expression, where a function is placed into the PHP Closure object and stored in a scoped variable.\n\n\n// Function Declaration\nfunction add($a, $b) {\n    return $a + $b;\n}\n\n// Function Expression\n$add = function($a, $b) {\n    return $a + $b;\n}\n\n\n\n\nWe can use a function expression in the same way we use a regular function:\n\n\n$add(1, 2); // Returns 3\n\n\n\n\nVector makes exclusive use of function expressions, both for consistency when combining functions together\nand for their scoped nature.\n\n\nUsing Vector Functions\n\n\nFunctions in Vector are organized into modules, which each have some related functionality or 'theme.' Simply call the function\nyou want to use as though it were a normal static function on the module in question.\n\n\nFor instance, if we want to use in the Vector wrapper function for \ncount\n called \nlength\n from the \nArrayList\n module, we would\nwrite:\n\n\nVector\\Lib\\ArrayList::length([1, 2, 3]); // 3\n\n\n\n\nIf you look at the ArrayList class in Vector\\Lib, you'll notice that there is not actually a \nlength\n function defined anywhere. Rather, there's a \n__length\n\nfunction that looks something like this:\n\n\nprotected static function __length($list)\n{\n    return count($list);\n}\n\n\n\n\nThe function module intercepts calls to static functions on a module and performs a set of operations under the hood and completely transparently. We'll\ngo into more detail about how this is implemented, and more importantly, how you can implement your own modules in the 'Module' section.\n\n\nIt's important to note that calling a function on a module with no arguments will return a closure that executes the requested function\nwhen invoked. For instance:\n\n\n$length = Vector\\Lib\\ArrayList::length();\n$length([1, 2, 3]); // 3\n\n\n\n\nAt first this may seem strange, but it's actually both intended and useful -- and a direct consequence of currying, which will we discuss next.\n\n\nCurrying\n\n\nCurrying is the act of modifying a function in such a way that it can accept its arguments in chunks. A curried function\ndoesn't have to be supplied all of its arguments in order to have some effect.\n\n\nSay we have a function that adds two numbers together.\n\n\n$add = function($a, $b) {\n    return $a + $b;\n}\n\n\n\n\nWhen we want to use add, we have to supply it two arguments, \n$a\n and \n$b\n. But say we want to give it is first argument,\ngo do something else, then come back and give it its second argument. We can curry the \n$add\n function to allow us to do this.\n\n\n$addCurried = function($a) {\n    return function($b) use ($a) {\n        return $a + $b;\n    }\n}\n\n\n\n\nNow we can use the \n$add\n function like this:\n\n\n$addNow = $addCurried(1); // $addNow = curried PHP closure\n$addLater = $addNow(2);   // $addLater = 3;\n\n\n\n\nWhy in the world would we ever want to do this? Currying in and of itself doesn't give us much,\nbut it has a powerful consequence: Partial Application.\n\n\nPartial Application\n\n\nNotice in the previous example how we stored the interim result of giving the first argument to our curried \n$add\n function in a local variable\ncalled \n$addNow\n. This variable is a function expression, and it can be used in the same way as any other function. The first argument we've given\nit has been closed over, and this is now a completely new function with different behaviors from \n$add\n. Let's rename it to \n$increment\n and see how it behaves:\n\n\n$increment = $addCurried(1);\n\n$increment(2); // 3\n$increment(0); // 1\n$increment(9); // 10\n\n\n\n\nWe've taken our \n$add\n function and created an increment function, without writing a single line of code aside from applying the first argument. We can create an infinite\nnumber of \n$addX\n functions in exactly the same way.\n\n\nAll functions in Vector are curried by default, so they can all be partially applied. This is why calling a Vector function with no arguments returns that function as a closure\nas we discussed in the \nUsing Vector Functions\n section.\n\n\nComposition\n\n\nWe've now seen how we can create functions from other functions by partially applying them. But there are other ways to create new functions from small components.\nWe can also compose them together, which is like creating a chain of steps for a function to step through, from beginning to end.\n\n\nVector provides a \ncompose\n function in the Lambda module which we can pull in and play around with. \ncompose\n takes its arguments and applies them sequentially from\nback to front -- provided every argument is a function.\n\n\nLet's say we want to create a function that converts from celcius to fahrenheit, and that we've already implmented the basic mathematical functions like\nadd, subtract, multiply, and divide. We can use \ncompose\n to chain all these calculations together to create a \ntoFahrenheit\n function:\n\n\n// Let's assume we have an $add and $multiply function. The Math module\n// provies these, but we'll just assume we have them in locally scoped closure objects.\n\n// Notice that compose returns a function.\n// In PHP 7+ you can invoke it immediately using Lambda::compose(...)($arg)\n$toFahrenheit = Lambda::compose(\n    $add(32),\n    $multiply(9/5)\n);\n\n$toFahrenheit(8); // Returns 46.4\n\n\n\n\nNotice how \ncompose\n reads: We first perform the operation last in the list, then move backward to the front of the list. This is laid out to match the mathematical definition\nof compose: \n(f \u2218 g)(x) = f(g(x))\n. If you can't wrap your head around the backwards nature, Vector also supplied a \npipe\n function on the Lambda module that acts as compose\nfrom front-to-back.\n\n\nNotice also how we used partial application to create helper functions from \n$add\n and \n$multiply\n. Partial application and composition\ncan be mixed and matched to create more complex functions from very simple components.\n\n\nLifting\n\n\nLet's use our \n$toFahrenheit\n function from before, but imagine instead that we want to apply it to a list of temperatures. Instead of looping over the\nlist in a procedural way, let's use \nmap\n from the ArrayList module.\n\n\n// Our list of temperatures\n$data = [50.0, 176.0, 212.0];\n\nArrayList::map($toFahrenheit, $data); // Returns [10, 80, 100]\n\n\n\n\nIf you've ever used PHP's \narray_map\n before, you should recognize what's going on. \nmap\n is taking a function with one input and one output, and sequentially\napplying it to every element in an array.\n\n\nHowever, \nmap\n is a function just like any other - it's curried, and it can be partially applied. If we partially apply \nmap\n, we've created a new function that now operates\non a list as opposed to a single element. We've lifted it from one domain to another. Let's see how we can use this in conjunction with partial application and composition, putting\nit all together.\n\n\nSay we have a set of temperature data from a weather API, but it's not the highest quality -- The values it gives us are one degree lower than they should be.\nOur task is to calculate the mean temperature from the temperature data after correcting the values by shifting\nthem one degree higher.\n\n\n// The Math module provides a mean function, and we're using $add and $toFahrenheit from above\n$correctedMeanTemp = Lambda::compose(\n    Math::mean(),\n    ArrayList::map(\n        Lambda::compose($toFahrenheit, $add(1))\n    )\n);\n\n\n\n\nNotice how we have created a function to complete our task without even bothering to load our data in - we don't need it. Our function will first\nadd one to every element in the dataset and then convert it to fahrenheit, then pass that mapped array to our mean function. This is called the point-free style.\n\n\nNow we can take our \n$correctedMeanTemp\n and add it to our own Vector module and use it throughout our codebase whenever we need to work with temperature data.\n\n\nIn the next section, we'll go over the Vector Module - how it works, and how you can make your own.", 
            "title": "Functional Basics"
        }, 
        {
            "location": "/user-guide/basics/#functional-basics", 
            "text": "First of all, what is functional programming?   In computer science, functional programming is a programming paradigm that treats computation\nas the evaluation of mathematical functions and avoids changing-state and mutable data.   Vector is a functional programming library that follows this credo and implements helpers and utilities\nthat allow you to do the same in your own code.  Before we get started, here's some things to know:", 
            "title": "Functional Basics"
        }, 
        {
            "location": "/user-guide/basics/#function-declaration-vs-function-expression", 
            "text": "You're probably very familiar with functions in PHP. But what you might not know is that there are\nmultiple ways to declare functions in PHP. The first is a declaration, where a function name is placed\ninto a function table keyed to its name and accessible globally (so long as it's loaded). The second method is\na function expression, where a function is placed into the PHP Closure object and stored in a scoped variable.  // Function Declaration\nfunction add($a, $b) {\n    return $a + $b;\n}\n\n// Function Expression\n$add = function($a, $b) {\n    return $a + $b;\n}  We can use a function expression in the same way we use a regular function:  $add(1, 2); // Returns 3  Vector makes exclusive use of function expressions, both for consistency when combining functions together\nand for their scoped nature.", 
            "title": "Function Declaration vs. Function Expression"
        }, 
        {
            "location": "/user-guide/basics/#using-vector-functions", 
            "text": "Functions in Vector are organized into modules, which each have some related functionality or 'theme.' Simply call the function\nyou want to use as though it were a normal static function on the module in question.  For instance, if we want to use in the Vector wrapper function for  count  called  length  from the  ArrayList  module, we would\nwrite:  Vector\\Lib\\ArrayList::length([1, 2, 3]); // 3  If you look at the ArrayList class in Vector\\Lib, you'll notice that there is not actually a  length  function defined anywhere. Rather, there's a  __length \nfunction that looks something like this:  protected static function __length($list)\n{\n    return count($list);\n}  The function module intercepts calls to static functions on a module and performs a set of operations under the hood and completely transparently. We'll\ngo into more detail about how this is implemented, and more importantly, how you can implement your own modules in the 'Module' section.  It's important to note that calling a function on a module with no arguments will return a closure that executes the requested function\nwhen invoked. For instance:  $length = Vector\\Lib\\ArrayList::length();\n$length([1, 2, 3]); // 3  At first this may seem strange, but it's actually both intended and useful -- and a direct consequence of currying, which will we discuss next.", 
            "title": "Using Vector Functions"
        }, 
        {
            "location": "/user-guide/basics/#currying", 
            "text": "Currying is the act of modifying a function in such a way that it can accept its arguments in chunks. A curried function\ndoesn't have to be supplied all of its arguments in order to have some effect.  Say we have a function that adds two numbers together.  $add = function($a, $b) {\n    return $a + $b;\n}  When we want to use add, we have to supply it two arguments,  $a  and  $b . But say we want to give it is first argument,\ngo do something else, then come back and give it its second argument. We can curry the  $add  function to allow us to do this.  $addCurried = function($a) {\n    return function($b) use ($a) {\n        return $a + $b;\n    }\n}  Now we can use the  $add  function like this:  $addNow = $addCurried(1); // $addNow = curried PHP closure\n$addLater = $addNow(2);   // $addLater = 3;  Why in the world would we ever want to do this? Currying in and of itself doesn't give us much,\nbut it has a powerful consequence: Partial Application.", 
            "title": "Currying"
        }, 
        {
            "location": "/user-guide/basics/#partial-application", 
            "text": "Notice in the previous example how we stored the interim result of giving the first argument to our curried  $add  function in a local variable\ncalled  $addNow . This variable is a function expression, and it can be used in the same way as any other function. The first argument we've given\nit has been closed over, and this is now a completely new function with different behaviors from  $add . Let's rename it to  $increment  and see how it behaves:  $increment = $addCurried(1);\n\n$increment(2); // 3\n$increment(0); // 1\n$increment(9); // 10  We've taken our  $add  function and created an increment function, without writing a single line of code aside from applying the first argument. We can create an infinite\nnumber of  $addX  functions in exactly the same way.  All functions in Vector are curried by default, so they can all be partially applied. This is why calling a Vector function with no arguments returns that function as a closure\nas we discussed in the  Using Vector Functions  section.", 
            "title": "Partial Application"
        }, 
        {
            "location": "/user-guide/basics/#composition", 
            "text": "We've now seen how we can create functions from other functions by partially applying them. But there are other ways to create new functions from small components.\nWe can also compose them together, which is like creating a chain of steps for a function to step through, from beginning to end.  Vector provides a  compose  function in the Lambda module which we can pull in and play around with.  compose  takes its arguments and applies them sequentially from\nback to front -- provided every argument is a function.  Let's say we want to create a function that converts from celcius to fahrenheit, and that we've already implmented the basic mathematical functions like\nadd, subtract, multiply, and divide. We can use  compose  to chain all these calculations together to create a  toFahrenheit  function:  // Let's assume we have an $add and $multiply function. The Math module\n// provies these, but we'll just assume we have them in locally scoped closure objects.\n\n// Notice that compose returns a function.\n// In PHP 7+ you can invoke it immediately using Lambda::compose(...)($arg)\n$toFahrenheit = Lambda::compose(\n    $add(32),\n    $multiply(9/5)\n);\n\n$toFahrenheit(8); // Returns 46.4  Notice how  compose  reads: We first perform the operation last in the list, then move backward to the front of the list. This is laid out to match the mathematical definition\nof compose:  (f \u2218 g)(x) = f(g(x)) . If you can't wrap your head around the backwards nature, Vector also supplied a  pipe  function on the Lambda module that acts as compose\nfrom front-to-back.  Notice also how we used partial application to create helper functions from  $add  and  $multiply . Partial application and composition\ncan be mixed and matched to create more complex functions from very simple components.", 
            "title": "Composition"
        }, 
        {
            "location": "/user-guide/basics/#lifting", 
            "text": "Let's use our  $toFahrenheit  function from before, but imagine instead that we want to apply it to a list of temperatures. Instead of looping over the\nlist in a procedural way, let's use  map  from the ArrayList module.  // Our list of temperatures\n$data = [50.0, 176.0, 212.0];\n\nArrayList::map($toFahrenheit, $data); // Returns [10, 80, 100]  If you've ever used PHP's  array_map  before, you should recognize what's going on.  map  is taking a function with one input and one output, and sequentially\napplying it to every element in an array.  However,  map  is a function just like any other - it's curried, and it can be partially applied. If we partially apply  map , we've created a new function that now operates\non a list as opposed to a single element. We've lifted it from one domain to another. Let's see how we can use this in conjunction with partial application and composition, putting\nit all together.  Say we have a set of temperature data from a weather API, but it's not the highest quality -- The values it gives us are one degree lower than they should be.\nOur task is to calculate the mean temperature from the temperature data after correcting the values by shifting\nthem one degree higher.  // The Math module provides a mean function, and we're using $add and $toFahrenheit from above\n$correctedMeanTemp = Lambda::compose(\n    Math::mean(),\n    ArrayList::map(\n        Lambda::compose($toFahrenheit, $add(1))\n    )\n);  Notice how we have created a function to complete our task without even bothering to load our data in - we don't need it. Our function will first\nadd one to every element in the dataset and then convert it to fahrenheit, then pass that mapped array to our mean function. This is called the point-free style.  Now we can take our  $correctedMeanTemp  and add it to our own Vector module and use it throughout our codebase whenever we need to work with temperature data.  In the next section, we'll go over the Vector Module - how it works, and how you can make your own.", 
            "title": "Lifting"
        }, 
        {
            "location": "/user-guide/module/", 
            "text": "The Vector Module\n\n\nThe Vector Module exists in the \nVector\\Core\n namespace, and every Vector module\nexists as a subclass of the Module. \nModule\n provides loads of benefits transparently, and\nstrives to be as simple as possible to implement.\n\n\nWhat it Does\n\n\nThe primary benefit of \nModule\n is that it will automatically curry the functions placed\ninside of it. This allows you to write your functions without worrying about manually\nadding the breakpoints for currying, or worrying about closing over curried arguments -- You can\nsimply write your function as through it receives all of its arguments at once, and let \nModule\n\nhandle the rest.\n\n\nThe \nModule\n also provides mechanisms for memoization -- caching function calls for long-running\nor expensive operations -- transparently and automatically.\n\n\nA side benefit of \nModule\n is that it allows you to autoload your functions with Composer.\nWhile later versions of PHP have namespaced functions, there is currently no way to autoload\nthem in Composer aside from using the \nautoload.files\n field in the \ncomposer.json\n file, which\nloads the file on every request regardless of whether or not it's needed.\n\n\nImplementing Your Own Module\n\n\nCreating the Module\n\n\nTo implement your own \nModule\n, simply create a new class and extend \nVector\\Core\\Module\n:\n\n\nclass MyModule extends Vector\\Core\\Module\n{\n}\n\n\n\n\nAdding Functions\n\n\nThe Module will intercept function calls using the \n__callStatic\n magic method from PHP. Because of this though,\nthe name of your function can't match the name that you call from your code. We choose to adopt the magic method standard and\ndeclare all of our functions with double underscores prefixed to their names.\n\n\nclass MyModule extends Vector\\Core\\Module\n{\n    protected static __myFunction($a, $b)\n    {\n        return $a . ' foo ' . $b;\n    }\n}\n\n\n\n\nRecommended practice is to declare the functions in a module as \nprotected\n. The functions \ncannot\n be \nprivate\n because the parent class \nModule\n needs\nto be able to access them. They \ncan\n be \npublic\n however, but it's best not to provide a way to call your raw function without passing it through the\n\nModule\n proxy.\n\n\nEnabling Memoization\n\n\nMemoized functions store the result of their execution in a private context, and can then short circuit their execution and return their result\nif called again with the same arguments. This is effectively free caching.\n\n\n\n\nImportant\n\n\nMemoization assumes that your functions are pure. If your functions have side effects, those side effects will not execute again\nif you memoize the function causing them! Avoid side effects!\n\n\n\n\nMemoization is disabled for new modules by default -- you must opt into it. To enable memoization for a single or multiple functions, override\nthe \n$memoize\n field on your module:\n\n\nclass MyModule extends Vector\\Core\\Module\n{\n    protected static $memoize = ['myFunction'];\n\n    protected static __myFunction($a, $b)\n    {\n        return $a . ' foo ' . $b;\n    }\n}\n\n\n\n\nAlternatively, to enable memoization for an entire module, set \n$memoize\n to \ntrue\n.\n\n\nNotice how we declared the function in our \n$memoize\n list -- we do not include the double underscore prefix of the function name. The \nModule\n\ntakes care of interpreting that for us. Just list your function names with their display names, or the names you would use when using them.\n\n\nDisabling Currying\n\n\nIf you for some reason don't want your function to be curried, you can override the\n\n$doNotCurry\n field on your module:\n\n\nclass MyModule extends Vector\\Core\\Module\n{\n    protected static $doNotCurry = ['myFunction'];\n\n    protected static __myFunction($a, $b)\n    {\n        return $a . ' foo ' . $b;\n    }\n}\n\n\n\n\nAlternatively, to disable currying for an entire module, set \n$doNotCurry\n to \ntrue\n.\n\n\nNotice again that we don't include the double underscore in the \n$doNotCurry\n array.\n\n\nGenerally speaking you should never need to do this. This exists as a side effect of the internal\ncurry implementation and is exposed only for any edge cases where you might need it.", 
            "title": "Vector Modules"
        }, 
        {
            "location": "/user-guide/module/#the-vector-module", 
            "text": "The Vector Module exists in the  Vector\\Core  namespace, and every Vector module\nexists as a subclass of the Module.  Module  provides loads of benefits transparently, and\nstrives to be as simple as possible to implement.", 
            "title": "The Vector Module"
        }, 
        {
            "location": "/user-guide/module/#what-it-does", 
            "text": "The primary benefit of  Module  is that it will automatically curry the functions placed\ninside of it. This allows you to write your functions without worrying about manually\nadding the breakpoints for currying, or worrying about closing over curried arguments -- You can\nsimply write your function as through it receives all of its arguments at once, and let  Module \nhandle the rest.  The  Module  also provides mechanisms for memoization -- caching function calls for long-running\nor expensive operations -- transparently and automatically.  A side benefit of  Module  is that it allows you to autoload your functions with Composer.\nWhile later versions of PHP have namespaced functions, there is currently no way to autoload\nthem in Composer aside from using the  autoload.files  field in the  composer.json  file, which\nloads the file on every request regardless of whether or not it's needed.", 
            "title": "What it Does"
        }, 
        {
            "location": "/user-guide/module/#implementing-your-own-module", 
            "text": "", 
            "title": "Implementing Your Own Module"
        }, 
        {
            "location": "/user-guide/module/#creating-the-module", 
            "text": "To implement your own  Module , simply create a new class and extend  Vector\\Core\\Module :  class MyModule extends Vector\\Core\\Module\n{\n}", 
            "title": "Creating the Module"
        }, 
        {
            "location": "/user-guide/module/#adding-functions", 
            "text": "The Module will intercept function calls using the  __callStatic  magic method from PHP. Because of this though,\nthe name of your function can't match the name that you call from your code. We choose to adopt the magic method standard and\ndeclare all of our functions with double underscores prefixed to their names.  class MyModule extends Vector\\Core\\Module\n{\n    protected static __myFunction($a, $b)\n    {\n        return $a . ' foo ' . $b;\n    }\n}  Recommended practice is to declare the functions in a module as  protected . The functions  cannot  be  private  because the parent class  Module  needs\nto be able to access them. They  can  be  public  however, but it's best not to provide a way to call your raw function without passing it through the Module  proxy.", 
            "title": "Adding Functions"
        }, 
        {
            "location": "/user-guide/module/#enabling-memoization", 
            "text": "Memoized functions store the result of their execution in a private context, and can then short circuit their execution and return their result\nif called again with the same arguments. This is effectively free caching.   Important  Memoization assumes that your functions are pure. If your functions have side effects, those side effects will not execute again\nif you memoize the function causing them! Avoid side effects!   Memoization is disabled for new modules by default -- you must opt into it. To enable memoization for a single or multiple functions, override\nthe  $memoize  field on your module:  class MyModule extends Vector\\Core\\Module\n{\n    protected static $memoize = ['myFunction'];\n\n    protected static __myFunction($a, $b)\n    {\n        return $a . ' foo ' . $b;\n    }\n}  Alternatively, to enable memoization for an entire module, set  $memoize  to  true .  Notice how we declared the function in our  $memoize  list -- we do not include the double underscore prefix of the function name. The  Module \ntakes care of interpreting that for us. Just list your function names with their display names, or the names you would use when using them.", 
            "title": "Enabling Memoization"
        }, 
        {
            "location": "/user-guide/module/#disabling-currying", 
            "text": "If you for some reason don't want your function to be curried, you can override the $doNotCurry  field on your module:  class MyModule extends Vector\\Core\\Module\n{\n    protected static $doNotCurry = ['myFunction'];\n\n    protected static __myFunction($a, $b)\n    {\n        return $a . ' foo ' . $b;\n    }\n}  Alternatively, to disable currying for an entire module, set  $doNotCurry  to  true .  Notice again that we don't include the double underscore in the  $doNotCurry  array.  Generally speaking you should never need to do this. This exists as a side effect of the internal\ncurry implementation and is exposed only for any edge cases where you might need it.", 
            "title": "Disabling Currying"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/", 
            "text": "bifurcate\n\n\nArray Bifurcation\n :: (a -\n Bool) -\n [a] -\n ([a], [a])\n\n\nGiven an array and some filtering test that returns a boolean, return two arrays - one array\nof elements that pass the test, and another array of elements that don't. Similar to filter,\nbut returns the elements that fail as well.\n\n\nArrayList::bifurcate($isEven, [1, 2, 3, 4, 5]); // [[2, 4], [1, 3, 5]]\n\n\n\n\n\n\nconcat\n\n\nArray Concatenation\n :: [a] -\n [a] -\n [a]\n\n\nJoins two arrays together, with the second argument being appended\nto the end of the first. Defers to php build-in function \narray_merge\n,\nso repeated keys will be overwritten.\n\n\nArrayList::concat([1, 2], [2, 3]); // [1, 2, 2, 3]\nArrayList::concat(['a' =\n 1, 'b' =\n 2], ['a' =\n 'foo', 'c' =\n 3]); // ['a' =\n 'foo', 'b' =\n 2, 'c' =\n 3]\n\n\n\n\n\n\ncons\n\n\nCons Operator\n :: a -\n [a] -\n [a]\n\n\nGiven a value and an array, append that value to the end of the array.\n\n\nArrayList::cons(3, [1, 2]); // [1, 2, 3]\nArrayList::cons(1, []); // [1]\n\n\n\n\n\n\ncontains\n\n\nArray Contains Element\n :: a -\n [a] -\n Bool\n\n\nReturns true if a given array contains the item to test, or false if\nit does not.\n\n\nArrayList::contains(1, [1, 2, 3]); // true\nArrayList::contains('a', ['b', 'c', 'd']); // false\n\n\n\n\n\n\ndrop\n\n\nDrop Elements\n :: Int -\n [a] -\n [a]\n\n\nGiven some number n, drop n elements from an input array and return the rest of\nthe elements. If n is greater than the length of the array, returns an empty array.\n\n\nArrayList::drop(2, [1, 2, 3, 4]); // [3, 4]\nArrayList::drop(4, [1, 2]); // []\n\n\n\n\n\n\ndropWhile\n\n\nDrop Elements with Predicate\n :: (a -\n Bool) -\n [a] -\n [a]\n\n\nGiven some function that returns true or false, drop elements from an array starting\nat the front, testing each element along the way, until that function returns false.\nReturn the array without all of those elements.\n\n\n$greaterThanOne = function($n) { return $n \n 1; };\nArrayList::dropWhile($greaterThanOne, [2, 4, 6, 1, 2, 3]); // [1, 2, 3]\n\n\n\n\n\n\nfilter\n\n\nFilter a List\n :: (a -\n Bool) -\n [a] -\n [a]\n\n\nReturns a filtered list. Given a function that takes an element and returns\neither true or false, return a list of all the elements\nof the input list that pass the test.\n\n\nArrayList::filter(function($a) { return $a \n 2; }, [1, 2, 3, 4, 5]); // [3, 4, 5], using an inline function\nArrayList::filter(function($a) { return $a \n 2; }, ['foo' =\n 1, 'bar' =\n 3]); // ['foo' =\n 1]\nArrayList::filter(Math::lte(2), [1, 2, 3, 4, 5]); // [1, 2], using `lte` from the Math module\n\n\n\n\n\n\nflatten\n\n\nArray Flatten\n :: [a] -\n [b]\n\n\nFlattens a nested array structure into a single-dimensional array. Can handle\narrays of arbitrary dimension.\n\n\nArrayList::flatten([1, [2], [[[3, 4, [5]]]]]); // [1, 2, 3, 4, 5]\n\n\n\n\n\n\nfoldl\n\n\nList Fold - From Left\n :: (b -\n a -\n b) -\n b -\n [a] -\n b\n\n\nFold a list by iterating over the list from left to right. Pass each element, one by one, into\nthe fold function $f, and carry its value over to the next iteration. Also referred to as array\nreduce.\n\n\n$add = function($a, $b) { return $a + $b; };\nArrayList::foldl(Math::add(), 0, [1, 2, 3]); // 6\nArrayList::foldl(Logic::and(), True, [True, True]); // True\nArrayList::foldl(Logic::and(), True, [True, True, False]); // False\n\n\n\n\n\n\ngroupBy\n\n\nGroup By\n :: (a -\n String) -\n [a] -\n [[a]]\n\n\nGiven a function that turns an element into a string, map over a list of elements\nand return a multi-dimensional array with elements grouped together by their key\ngenerator.\n\n\n$testCase = [1, 2, 3, 4, 5, 6, 7];\n$keyGen = function($a) {\n    return ($a \n= 3) ? 'small' : 'big';\n};\nArrayList::groupBy($keyGen, $testCase); // ['small' =\n [1, 2, 3], 'big' =\n [4, 5, 6, 7]]\n\n\n\n\n\n\nhead\n\n\nList Head\n :: [a] -\n a\n\n\nReturns the first element of a list, the element at index 0. Also functions\nproperly for key/value arrays, e.g. arrays whose first element may not necessarily\nbe index 0. If an empty array is given, head throws an Exception.\n\n\nArrayList::head([1, 2, 3]); // 1\nArrayList::head(['a' =\n 1, 'b' =\n 2]); // 1\nArrayList::head([]); // Exception thrown\n\n\n\n\n\n\nindex\n\n\nList Index\n :: Int -\n [a] -\n a\n\n\nReturns the element of a list at the given index. Throws an exception\nif the given index does not exist in the list.\n\n\nArrayList::index(0, [1, 2, 3]); // 1\nArrayList::index('foo', ['bar' =\n 1, 'foo' =\n 2]); // 2\nArrayList::index('baz', [1, 2, 3]); // Exception thrown\n\n\n\n\n\n\ninit\n\n\nInitial List Values\n :: [a] -\n [a]\n\n\nReturns an array without its last element, e.g. the inverse of \ntail\n. Works on\nkey/value arrays as well as 'regular' arrays. If an empty or single-value array is given,\nreturns an empty array.\n\n\nArrayList::init([1, 2, 3]); // [1, 2]\nArrayList::init(['a' =\n 1, 'b' =\n 2]); // ['a' =\n 1];\n\n\n\n\n\n\nkeys\n\n\nArray Keys\n :: [a] -\n [b]\n\n\nReturns the keys of an associative key/value array. Returns numerical indexes\nfor non key/value arrays.\n\n\nArrayList::keys(['a' =\n 1, 'b' =\n 2]); // ['a', 'b']\nArrayList::keys([1, 2, 3]); // [0, 1, 2]\n\n\n\n\n\n\nlast\n\n\nLast List Value\n :: [a] -\n a\n\n\nReturns the last element of an array, e.g. the complement of \ninit\n. Works on key/value\narrays as well as 'regular' arrays. If an empty array is given, throws an exception.\n\n\nArrayList::last([1, 2, 3]); // 3\nArrayList::last(['a' =\n 1, 'b' =\n 2]); // 2\nArrayList::last([]); // Exception thrown\n\n\n\n\n\n\nlength\n\n\nArray Length\n :: [a] -\n a\n\n\nReturns the length of a list or array. Wraps php \ncount\n function.\n\n\nArrayList::length([1, 2, 3]); // 3\nArrayList::length(['a' =\n 1, 'b' =\n 2]); // 2\n\n\n\n\n\n\nmap\n\n\nArray Map\n :: (a -\n b) -\n [a] -\n [b]\n\n\nGiven some function and a list of arbitrary length, return a new array that is the\nresult of calling the given function on each element of the original list.\n\n\nArrayList::map($add(1), [1, 2, 3]); // [2, 3, 4]\n\n\n\n\n\n\nmapIndexed\n\n\nArray Map Indexed\n :: (a -\n b -\n c) -\n [a] -\n [c]\n\n\nGiven some function and a list of arbitrary length, return a new array that is the\nresult of calling the given function on each element of the original list. The first argument\nof the mapping function is the value, and the second argument is the key or index of the array being\nmapped over.\n\n\nArrayList::mapIndexed($filterEvenIndexes, [1, 2, 3]); // [null, 2, null]\n\n\n\n\n\n\nreplicate\n\n\nReplicate Item\n :: Int -\n a -\n [a]\n\n\nGiven some integer n and an item to repeat, repeat that item and place\nthe results into an array of length n.\n\n\nArrayList::replicate(5, 'foo'); // ['foo', 'foo', 'foo', 'foo', 'foo']\n\n\n\n\n\n\nreverse\n\n\nArray Reverse\n :: [a] -\n [a]\n\n\nFlip the order of a given array. Does not modify the original array.\n\n\nArrayList::reverse([1, 2, 3]); // [3, 2, 1]\n\n\n\n\n\n\nsetIndex\n\n\nSet Array Value\n :: a -\n b -\n [b] -\n [b]\n\n\nSets the value of an array at the given index; works for non-numerical indexes.\nThe value is set in an immutable way, so the original array is not modified.\n\n\nArrayList::setValue(0, 'foo', [1, 2, 3]); // ['foo', 2, 3]\nArrayList::setValue('c', 3, ['a' =\n 1, 'b' =\n 2]); // ['a' =\n 1, 'b' =\n 2, 'c' =\n 3]\n\n\n\n\n\n\nsort\n\n\nArray Sort\n :: (a -\n a -\n Int) -\n [a] -\n [a]\n\n\nGiven a function that compares two values, sort an array. This function defers to usort\nbut does not mutate the original array. The comparison function should return -1 if the\nfirst argument is ordered before the second, 0 if it's the same ordering, and 1 if\nfirst argument is ordered after the second.\n\n\n$comp = function($a, $b) { return $a \n=\n $b; };\nArrayList::sort($comp, [3, 2, 1]);\n\n\n\n\n\n\ntail\n\n\nList Tail\n :: [a] -\n [a]\n\n\nReturns an array without its first element, e.g. the complement of \nhead\n. Works on\nkey/value arrays as well as 'regular' arrays. If an empty array of an array of one element\nis given, returns an empty array.\n\n\nArrayList::([1, 2, 3]); // [2, 3]\nArrayList::(['a' =\n 1, 'b' =\n 2]); // ['b' =\n 2];\n\n\n\n\n\n\ntake\n\n\nTake Elements\n :: Int -\n [a] -\n [a]\n\n\nGiven some number n, return the first n elements of a given array. Returns the whole\narray if n is greater than the array length.\n\n\nArrayList::take(3, [1, 2, 3, 4, 5]); // [1, 2, 3]\n\n\n\n\n\n\ntakeWhile\n\n\nTake Elements with Predicate\n :: (a -\n Bool) -\n [a] -\n [a]\n\n\nGiven some function that returns true or false, return the first elements of the array\nthat all pass the test, until the test fails.\n\n\n$greaterThanOne = function($n) { return $n \n 1; };\nArrayList::takeWhile($greaterThanOne, [5, 5, 5, 1, 5, 5]); // [5, 5, 5]\n\n\n\n\n\n\nvalues\n\n\nArray Values\n :: [a] -\n [a]\n\n\nReturns the values of an associative key/value array.\n\n\nArrayList::values(['a' =\n 1, 'b' =\n 2]); // [1, 2]\nArrayList::values([1, 2, 3]); // [1, 2, 3]\n\n\n\n\n\n\nzip\n\n\nArray Zip\n :: [a] -\n [b] -\n [(a, b)]\n\n\nGiven two arrays a and b, return a new array where each element is a tuple of a and b. If a and b\nare not the same length, the resultant array will always be the same length as the shorter array.\n\n\nArrayList::zip([1, 2, 3], ['a', 'b', 'c']); // [[1, 'a'], [2, 'b'], [3, 'c']]\n\n\n\n\n\n\nzipWith\n\n\nCustom Array Zip\n :: (a -\n b -\n c) -\n [a] -\n [b] -\n [c]\n\n\nGiven two arrays a and b, and some combinator f, combine the arrays using the combinator\nf(ai, bi) into a new array c. If a and b are not the same length, the resultant array will\nalways be the same length as the shorter array, i.e. the zip stops when it runs out of pairs.\n\n\n$combinator = function($a, $b) { return $a + $b; };\nArrayList::zipWith($combinator, [1, 2, 3], [0, 8, -1]); // [1, 10, 2]\n$combinator = function($a, $b) { return $a - $b; };\nArrayList::zipWith($combinator, [0], [1, 2, 3]); // [-1]", 
            "title": "ArrayList"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#bifurcate", 
            "text": "Array Bifurcation  :: (a -  Bool) -  [a] -  ([a], [a])  Given an array and some filtering test that returns a boolean, return two arrays - one array\nof elements that pass the test, and another array of elements that don't. Similar to filter,\nbut returns the elements that fail as well.  ArrayList::bifurcate($isEven, [1, 2, 3, 4, 5]); // [[2, 4], [1, 3, 5]]", 
            "title": "bifurcate"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#concat", 
            "text": "Array Concatenation  :: [a] -  [a] -  [a]  Joins two arrays together, with the second argument being appended\nto the end of the first. Defers to php build-in function  array_merge ,\nso repeated keys will be overwritten.  ArrayList::concat([1, 2], [2, 3]); // [1, 2, 2, 3]\nArrayList::concat(['a' =  1, 'b' =  2], ['a' =  'foo', 'c' =  3]); // ['a' =  'foo', 'b' =  2, 'c' =  3]", 
            "title": "concat"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#cons", 
            "text": "Cons Operator  :: a -  [a] -  [a]  Given a value and an array, append that value to the end of the array.  ArrayList::cons(3, [1, 2]); // [1, 2, 3]\nArrayList::cons(1, []); // [1]", 
            "title": "cons"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#contains", 
            "text": "Array Contains Element  :: a -  [a] -  Bool  Returns true if a given array contains the item to test, or false if\nit does not.  ArrayList::contains(1, [1, 2, 3]); // true\nArrayList::contains('a', ['b', 'c', 'd']); // false", 
            "title": "contains"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#drop", 
            "text": "Drop Elements  :: Int -  [a] -  [a]  Given some number n, drop n elements from an input array and return the rest of\nthe elements. If n is greater than the length of the array, returns an empty array.  ArrayList::drop(2, [1, 2, 3, 4]); // [3, 4]\nArrayList::drop(4, [1, 2]); // []", 
            "title": "drop"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#dropwhile", 
            "text": "Drop Elements with Predicate  :: (a -  Bool) -  [a] -  [a]  Given some function that returns true or false, drop elements from an array starting\nat the front, testing each element along the way, until that function returns false.\nReturn the array without all of those elements.  $greaterThanOne = function($n) { return $n   1; };\nArrayList::dropWhile($greaterThanOne, [2, 4, 6, 1, 2, 3]); // [1, 2, 3]", 
            "title": "dropWhile"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#filter", 
            "text": "Filter a List  :: (a -  Bool) -  [a] -  [a]  Returns a filtered list. Given a function that takes an element and returns\neither true or false, return a list of all the elements\nof the input list that pass the test.  ArrayList::filter(function($a) { return $a   2; }, [1, 2, 3, 4, 5]); // [3, 4, 5], using an inline function\nArrayList::filter(function($a) { return $a   2; }, ['foo' =  1, 'bar' =  3]); // ['foo' =  1]\nArrayList::filter(Math::lte(2), [1, 2, 3, 4, 5]); // [1, 2], using `lte` from the Math module", 
            "title": "filter"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#flatten", 
            "text": "Array Flatten  :: [a] -  [b]  Flattens a nested array structure into a single-dimensional array. Can handle\narrays of arbitrary dimension.  ArrayList::flatten([1, [2], [[[3, 4, [5]]]]]); // [1, 2, 3, 4, 5]", 
            "title": "flatten"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#foldl", 
            "text": "List Fold - From Left  :: (b -  a -  b) -  b -  [a] -  b  Fold a list by iterating over the list from left to right. Pass each element, one by one, into\nthe fold function $f, and carry its value over to the next iteration. Also referred to as array\nreduce.  $add = function($a, $b) { return $a + $b; };\nArrayList::foldl(Math::add(), 0, [1, 2, 3]); // 6\nArrayList::foldl(Logic::and(), True, [True, True]); // True\nArrayList::foldl(Logic::and(), True, [True, True, False]); // False", 
            "title": "foldl"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#groupby", 
            "text": "Group By  :: (a -  String) -  [a] -  [[a]]  Given a function that turns an element into a string, map over a list of elements\nand return a multi-dimensional array with elements grouped together by their key\ngenerator.  $testCase = [1, 2, 3, 4, 5, 6, 7];\n$keyGen = function($a) {\n    return ($a  = 3) ? 'small' : 'big';\n};\nArrayList::groupBy($keyGen, $testCase); // ['small' =  [1, 2, 3], 'big' =  [4, 5, 6, 7]]", 
            "title": "groupBy"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#head", 
            "text": "List Head  :: [a] -  a  Returns the first element of a list, the element at index 0. Also functions\nproperly for key/value arrays, e.g. arrays whose first element may not necessarily\nbe index 0. If an empty array is given, head throws an Exception.  ArrayList::head([1, 2, 3]); // 1\nArrayList::head(['a' =  1, 'b' =  2]); // 1\nArrayList::head([]); // Exception thrown", 
            "title": "head"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#index", 
            "text": "List Index  :: Int -  [a] -  a  Returns the element of a list at the given index. Throws an exception\nif the given index does not exist in the list.  ArrayList::index(0, [1, 2, 3]); // 1\nArrayList::index('foo', ['bar' =  1, 'foo' =  2]); // 2\nArrayList::index('baz', [1, 2, 3]); // Exception thrown", 
            "title": "index"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#init", 
            "text": "Initial List Values  :: [a] -  [a]  Returns an array without its last element, e.g. the inverse of  tail . Works on\nkey/value arrays as well as 'regular' arrays. If an empty or single-value array is given,\nreturns an empty array.  ArrayList::init([1, 2, 3]); // [1, 2]\nArrayList::init(['a' =  1, 'b' =  2]); // ['a' =  1];", 
            "title": "init"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#keys", 
            "text": "Array Keys  :: [a] -  [b]  Returns the keys of an associative key/value array. Returns numerical indexes\nfor non key/value arrays.  ArrayList::keys(['a' =  1, 'b' =  2]); // ['a', 'b']\nArrayList::keys([1, 2, 3]); // [0, 1, 2]", 
            "title": "keys"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#last", 
            "text": "Last List Value  :: [a] -  a  Returns the last element of an array, e.g. the complement of  init . Works on key/value\narrays as well as 'regular' arrays. If an empty array is given, throws an exception.  ArrayList::last([1, 2, 3]); // 3\nArrayList::last(['a' =  1, 'b' =  2]); // 2\nArrayList::last([]); // Exception thrown", 
            "title": "last"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#length", 
            "text": "Array Length  :: [a] -  a  Returns the length of a list or array. Wraps php  count  function.  ArrayList::length([1, 2, 3]); // 3\nArrayList::length(['a' =  1, 'b' =  2]); // 2", 
            "title": "length"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#map", 
            "text": "Array Map  :: (a -  b) -  [a] -  [b]  Given some function and a list of arbitrary length, return a new array that is the\nresult of calling the given function on each element of the original list.  ArrayList::map($add(1), [1, 2, 3]); // [2, 3, 4]", 
            "title": "map"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#mapindexed", 
            "text": "Array Map Indexed  :: (a -  b -  c) -  [a] -  [c]  Given some function and a list of arbitrary length, return a new array that is the\nresult of calling the given function on each element of the original list. The first argument\nof the mapping function is the value, and the second argument is the key or index of the array being\nmapped over.  ArrayList::mapIndexed($filterEvenIndexes, [1, 2, 3]); // [null, 2, null]", 
            "title": "mapIndexed"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#replicate", 
            "text": "Replicate Item  :: Int -  a -  [a]  Given some integer n and an item to repeat, repeat that item and place\nthe results into an array of length n.  ArrayList::replicate(5, 'foo'); // ['foo', 'foo', 'foo', 'foo', 'foo']", 
            "title": "replicate"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#reverse", 
            "text": "Array Reverse  :: [a] -  [a]  Flip the order of a given array. Does not modify the original array.  ArrayList::reverse([1, 2, 3]); // [3, 2, 1]", 
            "title": "reverse"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#setindex", 
            "text": "Set Array Value  :: a -  b -  [b] -  [b]  Sets the value of an array at the given index; works for non-numerical indexes.\nThe value is set in an immutable way, so the original array is not modified.  ArrayList::setValue(0, 'foo', [1, 2, 3]); // ['foo', 2, 3]\nArrayList::setValue('c', 3, ['a' =  1, 'b' =  2]); // ['a' =  1, 'b' =  2, 'c' =  3]", 
            "title": "setIndex"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#sort", 
            "text": "Array Sort  :: (a -  a -  Int) -  [a] -  [a]  Given a function that compares two values, sort an array. This function defers to usort\nbut does not mutate the original array. The comparison function should return -1 if the\nfirst argument is ordered before the second, 0 if it's the same ordering, and 1 if\nfirst argument is ordered after the second.  $comp = function($a, $b) { return $a  =  $b; };\nArrayList::sort($comp, [3, 2, 1]);", 
            "title": "sort"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#tail", 
            "text": "List Tail  :: [a] -  [a]  Returns an array without its first element, e.g. the complement of  head . Works on\nkey/value arrays as well as 'regular' arrays. If an empty array of an array of one element\nis given, returns an empty array.  ArrayList::([1, 2, 3]); // [2, 3]\nArrayList::(['a' =  1, 'b' =  2]); // ['b' =  2];", 
            "title": "tail"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#take", 
            "text": "Take Elements  :: Int -  [a] -  [a]  Given some number n, return the first n elements of a given array. Returns the whole\narray if n is greater than the array length.  ArrayList::take(3, [1, 2, 3, 4, 5]); // [1, 2, 3]", 
            "title": "take"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#takewhile", 
            "text": "Take Elements with Predicate  :: (a -  Bool) -  [a] -  [a]  Given some function that returns true or false, return the first elements of the array\nthat all pass the test, until the test fails.  $greaterThanOne = function($n) { return $n   1; };\nArrayList::takeWhile($greaterThanOne, [5, 5, 5, 1, 5, 5]); // [5, 5, 5]", 
            "title": "takeWhile"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#values", 
            "text": "Array Values  :: [a] -  [a]  Returns the values of an associative key/value array.  ArrayList::values(['a' =  1, 'b' =  2]); // [1, 2]\nArrayList::values([1, 2, 3]); // [1, 2, 3]", 
            "title": "values"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#zip", 
            "text": "Array Zip  :: [a] -  [b] -  [(a, b)]  Given two arrays a and b, return a new array where each element is a tuple of a and b. If a and b\nare not the same length, the resultant array will always be the same length as the shorter array.  ArrayList::zip([1, 2, 3], ['a', 'b', 'c']); // [[1, 'a'], [2, 'b'], [3, 'c']]", 
            "title": "zip"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#zipwith", 
            "text": "Custom Array Zip  :: (a -  b -  c) -  [a] -  [b] -  [c]  Given two arrays a and b, and some combinator f, combine the arrays using the combinator\nf(ai, bi) into a new array c. If a and b are not the same length, the resultant array will\nalways be the same length as the shorter array, i.e. the zip stops when it runs out of pairs.  $combinator = function($a, $b) { return $a + $b; };\nArrayList::zipWith($combinator, [1, 2, 3], [0, 8, -1]); // [1, 10, 2]\n$combinator = function($a, $b) { return $a - $b; };\nArrayList::zipWith($combinator, [0], [1, 2, 3]); // [-1]", 
            "title": "zipWith"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Lambda/", 
            "text": "compose\n\n\nThis function is currently missing documentation.\n\n\n\n\nflip\n\n\nFlip Combinator\n :: (a -\n b -\n c) -\n b -\n a -\n c\n\n\nGiven a function that takes two arguments, return a new function that\ntakes those two arguments with their order reversed.\n\n\nMath::subtract(2, 6); // 4\nLambda::flip(Math::subtract())(2, 6); // -4\n\n\n\n\n\n\nid\n\n\nIdentity Function\n :: a -\n a\n\n\nGiven some value a, return a unchanged\n\n\nLambda::id(4); // 4\nLambda::id('foo'); // 'foo'\n\n\n\n\n\n\nk\n\n\nK Combinator\n :: a -\n (b -\n a)\n\n\nGiven some value k, return a lambda expression which always evaluates to k, regardless\nof any arguments it is given.\n\n\n$alwaysFour = Lambda::k(4);\n$alwaysFour('foo'); // 4\n$alwaysFour(1, 2, 3); // 4\n$alwaysFour(); // 4\n\n\n\n\n\n\npipe\n\n\nThis function is currently missing documentation.", 
            "title": "Lambda"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Lambda/#compose", 
            "text": "This function is currently missing documentation.", 
            "title": "compose"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Lambda/#flip", 
            "text": "Flip Combinator  :: (a -  b -  c) -  b -  a -  c  Given a function that takes two arguments, return a new function that\ntakes those two arguments with their order reversed.  Math::subtract(2, 6); // 4\nLambda::flip(Math::subtract())(2, 6); // -4", 
            "title": "flip"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Lambda/#id", 
            "text": "Identity Function  :: a -  a  Given some value a, return a unchanged  Lambda::id(4); // 4\nLambda::id('foo'); // 'foo'", 
            "title": "id"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Lambda/#k", 
            "text": "K Combinator  :: a -  (b -  a)  Given some value k, return a lambda expression which always evaluates to k, regardless\nof any arguments it is given.  $alwaysFour = Lambda::k(4);\n$alwaysFour('foo'); // 4\n$alwaysFour(1, 2, 3); // 4\n$alwaysFour(); // 4", 
            "title": "k"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Lambda/#pipe", 
            "text": "This function is currently missing documentation.", 
            "title": "pipe"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/", 
            "text": "all\n\n\nAll\n :: array -\n Bool\n\n\nReturns true given all values are truthy\n\n\nLogic::all(1, 'asdf', true); // True\nLogic::all(1, false); // False\n\n\n\n\n\n\nandCombinator\n\n\nLogical And Combinator\n :: [(a -\n Bool)] -\n a -\n Bool\n\n\nGiven two functions f and g, combine them in such a way to produce a new\nfunction h that returns true given f(x) AND g(x) returns true.\n\n\n$funcF = function($x) { return $x \n 5; };\n$funcG = function($x) { return $x \n 0; };\n$combinator = Logic::andCombinator([$funcF, $funcG]);\n$combinator(4); // True\n$combinator(2); // True\n$combinator(7); // False\n\n\n\n\n\n\nany\n\n\nAny\n :: array -\n Bool\n\n\nReturns true given any values are truthy\n\n\nLogic::any(true, false); // True\nLogic::any(false, false); // False\n\n\n\n\n\n\neq\n\n\nEqual (Not Strict / ==)\n :: mixed -\n mixed -\n Bool\n\n\nReturns true given $a equals $b\n\n\nLogic::eq(1, 1); // True\nLogic::eq(1, 2); // False\n\n\n\n\n\n\neqStrict\n\n\nEqual (Strict / ===)\n :: mixed -\n mixed -\n Bool\n\n\nReturns true given $a equals $b\n\n\nLogic::eqStrict(1, 1); // True\nLogic::eqStrict(1, '1'); // False\n\n\n\n\n\n\ngt\n\n\nGreater Than\n :: mixed -\n mixed -\n Bool\n\n\nReturns true given $b is greater than $a.\n\n\nLogic::gt(2, 1); // False\nLogic::gt(1, 2); // True\n\n\n\n\n\n\ngte\n\n\nGreater Than Or Equal\n :: mixed -\n mixed -\n Bool\n\n\nReturns true given $b is greater than or equal to $a.\n\n\nLogic::gte(1, 1); // True\nLogic::gte(1, 2); // True\n\n\n\n\n\n\nlogicalAnd\n\n\nLogical And\n :: Bool -\n Bool -\n Bool\n\n\nReturns true given $a AND $b are true.\n\n\nLogic::logicalAnd(true, true); // True\nLogic::logicalAnd(true, false); // False\n\n\n\n\n\n\nlogicalNot\n\n\nLogical Not\n :: Bool -\n Bool\n\n\nReturns true given $a is false.\nReturns false given $a is true.\n\n\nLogic::logicalNot(true); // False\nLogic::logicalNot(false); // True\n\n\n\n\n\n\nlogicalOr\n\n\nLogical Or\n :: Bool -\n Bool -\n Bool\n\n\nReturns true given $a OR $b returns true.\n\n\nLogic::logicalOr(true, false); // True\nLogic::logicalOr(false, false); // False\n\n\n\n\n\n\nlt\n\n\nLess Than\n :: mixed -\n mixed -\n Bool\n\n\nReturns true given $b is less than $a.\n\n\nLogic::lt(2, 1); // True\nLogic::lt(1, 2); // False\n\n\n\n\n\n\nlte\n\n\nLess Than Or Equal\n :: mixed -\n mixed -\n Bool\n\n\nReturns true given $b is less than or equal to $a.\n\n\nLogic::lte(1, 1); // True\nLogic::lte(2, 1); // True\n\n\n\n\n\n\nnot\n\n\nLogical Not\n :: Bool -\n Bool\n\n\nReturns the inverse of $a\n\n\nLogic::not(false); // true\n\n\n\n\n\n\nnotEq\n\n\nNot Equal (Not Strict / ==)\n :: mixed -\n mixed -\n Bool\n\n\nReturns true given $a does not equal $b\n\n\nLogic::notEq(1, 1); // False\nLogic::notEq(1, 2); // True\n\n\n\n\n\n\nnotEqStrict\n\n\nNot Equal (Strict / ===)\n :: mixed -\n mixed -\n Bool\n\n\nReturns true given $a does not equal $b\n\n\nLogic::notEqStrict(1, 2); // True\nLogic::notEqStrict(1, '1'); // False\n\n\n\n\n\n\norCombinator\n\n\nLogical Or Combinator\n :: [(a -\n Bool)] -\n a -\n Bool\n\n\nGiven two functions f and g, combine them in such a way to produce a new\nfunction h that returns true given f(x) OR g(x) returns true.\n\n\n$funcF = function($x) { return $x \n= 5; };\n$funcG = function($x) { return $x == 0; };\n$combinator = Logic::orCombinator([$funcF, $funcG]);\n$combinator(9); // True\n$combinator(0); // True\n$combinator(2); // False", 
            "title": "Logic"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#all", 
            "text": "All  :: array -  Bool  Returns true given all values are truthy  Logic::all(1, 'asdf', true); // True\nLogic::all(1, false); // False", 
            "title": "all"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#andcombinator", 
            "text": "Logical And Combinator  :: [(a -  Bool)] -  a -  Bool  Given two functions f and g, combine them in such a way to produce a new\nfunction h that returns true given f(x) AND g(x) returns true.  $funcF = function($x) { return $x   5; };\n$funcG = function($x) { return $x   0; };\n$combinator = Logic::andCombinator([$funcF, $funcG]);\n$combinator(4); // True\n$combinator(2); // True\n$combinator(7); // False", 
            "title": "andCombinator"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#any", 
            "text": "Any  :: array -  Bool  Returns true given any values are truthy  Logic::any(true, false); // True\nLogic::any(false, false); // False", 
            "title": "any"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#eq", 
            "text": "Equal (Not Strict / ==)  :: mixed -  mixed -  Bool  Returns true given $a equals $b  Logic::eq(1, 1); // True\nLogic::eq(1, 2); // False", 
            "title": "eq"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#eqstrict", 
            "text": "Equal (Strict / ===)  :: mixed -  mixed -  Bool  Returns true given $a equals $b  Logic::eqStrict(1, 1); // True\nLogic::eqStrict(1, '1'); // False", 
            "title": "eqStrict"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#gt", 
            "text": "Greater Than  :: mixed -  mixed -  Bool  Returns true given $b is greater than $a.  Logic::gt(2, 1); // False\nLogic::gt(1, 2); // True", 
            "title": "gt"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#gte", 
            "text": "Greater Than Or Equal  :: mixed -  mixed -  Bool  Returns true given $b is greater than or equal to $a.  Logic::gte(1, 1); // True\nLogic::gte(1, 2); // True", 
            "title": "gte"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#logicaland", 
            "text": "Logical And  :: Bool -  Bool -  Bool  Returns true given $a AND $b are true.  Logic::logicalAnd(true, true); // True\nLogic::logicalAnd(true, false); // False", 
            "title": "logicalAnd"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#logicalnot", 
            "text": "Logical Not  :: Bool -  Bool  Returns true given $a is false.\nReturns false given $a is true.  Logic::logicalNot(true); // False\nLogic::logicalNot(false); // True", 
            "title": "logicalNot"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#logicalor", 
            "text": "Logical Or  :: Bool -  Bool -  Bool  Returns true given $a OR $b returns true.  Logic::logicalOr(true, false); // True\nLogic::logicalOr(false, false); // False", 
            "title": "logicalOr"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#lt", 
            "text": "Less Than  :: mixed -  mixed -  Bool  Returns true given $b is less than $a.  Logic::lt(2, 1); // True\nLogic::lt(1, 2); // False", 
            "title": "lt"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#lte", 
            "text": "Less Than Or Equal  :: mixed -  mixed -  Bool  Returns true given $b is less than or equal to $a.  Logic::lte(1, 1); // True\nLogic::lte(2, 1); // True", 
            "title": "lte"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#not", 
            "text": "Logical Not  :: Bool -  Bool  Returns the inverse of $a  Logic::not(false); // true", 
            "title": "not"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#noteq", 
            "text": "Not Equal (Not Strict / ==)  :: mixed -  mixed -  Bool  Returns true given $a does not equal $b  Logic::notEq(1, 1); // False\nLogic::notEq(1, 2); // True", 
            "title": "notEq"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#noteqstrict", 
            "text": "Not Equal (Strict / ===)  :: mixed -  mixed -  Bool  Returns true given $a does not equal $b  Logic::notEqStrict(1, 2); // True\nLogic::notEqStrict(1, '1'); // False", 
            "title": "notEqStrict"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#orcombinator", 
            "text": "Logical Or Combinator  :: [(a -  Bool)] -  a -  Bool  Given two functions f and g, combine them in such a way to produce a new\nfunction h that returns true given f(x) OR g(x) returns true.  $funcF = function($x) { return $x  = 5; };\n$funcG = function($x) { return $x == 0; };\n$combinator = Logic::orCombinator([$funcF, $funcG]);\n$combinator(9); // True\n$combinator(0); // True\n$combinator(2); // False", 
            "title": "orCombinator"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Math/", 
            "text": "add\n\n\nArithmetic Addition\n :: Number a =\n a -\n a -\n a\n\n\nAdd two numbers together.\n\n\nMath::add(2, 2); // 4\nMath::add(-1, 2); // 1\n\n\n\n\n\n\ndivide\n\n\nArithmetic Division\n :: Number a =\n a -\n a -\n a\n\n\nDivide two numbers, with the first argument being the divisor.\n\n\nMath::divide(2, 8); // 4\nMath::divide(4, 12); // 3\n\n\n\n\n\n\nmax\n\n\nMaximum Value\n :: Number a =\n a -\n a -\n a\n\n\nReturns the maximum of two arguments a and b. If a and b are equal, just returns the value.\n\n\nMath::max(1, 2); // 2\nMath::max(-1, -6); // -1\nMath::max(5, 5); // 5\n\n\n\n\n\n\nmean\n\n\nArithmetic mean\n :: Number a =\n [a] -\n a\n\n\nReturns the average of a list, or zero for an empty list.\n\n\nMath::mean([1, 2, 3]); // (1 + 2 + 3) / 3 = 2\nMath::mean([]); // 0\n\n\n\n\n\n\nmin\n\n\nMinimum Value\n :: Number a =\n a -\n a -\n a\n\n\nReturns the minimum of two arguments a and b.\nIf a and be are equal, returns the first value. But since they're equal, that doesn't\nreally matter now does it?\n\n\nMath::min(1, 2); // 1\nMath::min(-1, -6); // -6\nMath::min(5, 5); // 5\n\n\n\n\n\n\nmod\n\n\nModulus Operator\n :: Int -\n Int -\n Int\n\n\nTake the modulus of two integers, with the first argument being the divisor.\nReturns the remainder of $b / $a.\n\n\nMath::mod(2, 5); // 1\nMath::mod(5, 12); // 2\nMath::mod(3, 3); // 0\n\n\n\n\n\n\nmultiply\n\n\nArithmetic Multiplication\n :: Number a =\n a -\n a -\n a\n\n\nMultiply two numbers together.\n\n\nMath::multiply(2, 4); // 8\nMath::multiply(0, 4); // 0\n\n\n\n\n\n\nnegate\n\n\nNegate a number.\n :: Number a =\n a -\n a\n\n\nReturns a given number * -1.\n\n\nMath::negate(4); // -4\nMath::negate(0); // 0\n\n\n\n\n\n\npow\n\n\nPower function\n :: Number a =\n a -\n a -\n a\n\n\nArithmetic exponentiation. Raises the second argument to the power\nof the first.\n\n\nMath::pow(2, 3); // 3 ^ 2 = 9\nMath::pow(3, 2); // 2 ^ 3 = 8\n\n\n\n\n\n\nproduct\n\n\nArray Product\n :: Number a =\n [a] -\n a\n\n\nReturns the product of a list of numbers, i.e. the result of multiplying\nevery element of a list together. Returns 1 for an empty list.\n\n\nMath::product([2, 2, 3]); // 12\nMath::product([]); // 1\n\n\n\n\n\n\nrange\n\n\nNumber Range\n :: Number a =\n a -\n a -\n a\n\n\nGiven two values m and n, return all values between m and n in an array, inclusive, with a\nstep size of $step. The list of numbers will start at the first value and approach the second value.\n\n\nMath::range(1, 1, 5); // [1, 2, 3, 4, 5]\nMath::range(2, 0, -3); // [0, -2]\nMath::range(0, 0, 0); // [0]\nMath::range(0.1, 0, 0.5); // [0, 0.1, 0.2, 0.3, 0.4, 0.5]\n\n\n\n\n\n\nsubtract\n\n\nArithmetic Subtraction.\n :: Number a =\n a -\n a -\n a\n\n\nSubtracts two numbers, with the first argument being subtracted from the second.\n\n\nMath::subtract(4, 9); // 5\nMath::subtract(-1, 3); // 4\n\n\n\n\n\n\nsum\n\n\nArray Sum\n :: Number a =\n [a] -\n a\n\n\nAdd all the numbers of a list together and return their sum. If the given\nlist is empty, returns 0.\n\n\nMath::sum([1, 2, 3]); // 6\nMath::sum([]); // 0", 
            "title": "Math"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Math/#add", 
            "text": "Arithmetic Addition  :: Number a =  a -  a -  a  Add two numbers together.  Math::add(2, 2); // 4\nMath::add(-1, 2); // 1", 
            "title": "add"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Math/#divide", 
            "text": "Arithmetic Division  :: Number a =  a -  a -  a  Divide two numbers, with the first argument being the divisor.  Math::divide(2, 8); // 4\nMath::divide(4, 12); // 3", 
            "title": "divide"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Math/#max", 
            "text": "Maximum Value  :: Number a =  a -  a -  a  Returns the maximum of two arguments a and b. If a and b are equal, just returns the value.  Math::max(1, 2); // 2\nMath::max(-1, -6); // -1\nMath::max(5, 5); // 5", 
            "title": "max"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Math/#mean", 
            "text": "Arithmetic mean  :: Number a =  [a] -  a  Returns the average of a list, or zero for an empty list.  Math::mean([1, 2, 3]); // (1 + 2 + 3) / 3 = 2\nMath::mean([]); // 0", 
            "title": "mean"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Math/#min", 
            "text": "Minimum Value  :: Number a =  a -  a -  a  Returns the minimum of two arguments a and b.\nIf a and be are equal, returns the first value. But since they're equal, that doesn't\nreally matter now does it?  Math::min(1, 2); // 1\nMath::min(-1, -6); // -6\nMath::min(5, 5); // 5", 
            "title": "min"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Math/#mod", 
            "text": "Modulus Operator  :: Int -  Int -  Int  Take the modulus of two integers, with the first argument being the divisor.\nReturns the remainder of $b / $a.  Math::mod(2, 5); // 1\nMath::mod(5, 12); // 2\nMath::mod(3, 3); // 0", 
            "title": "mod"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Math/#multiply", 
            "text": "Arithmetic Multiplication  :: Number a =  a -  a -  a  Multiply two numbers together.  Math::multiply(2, 4); // 8\nMath::multiply(0, 4); // 0", 
            "title": "multiply"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Math/#negate", 
            "text": "Negate a number.  :: Number a =  a -  a  Returns a given number * -1.  Math::negate(4); // -4\nMath::negate(0); // 0", 
            "title": "negate"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Math/#pow", 
            "text": "Power function  :: Number a =  a -  a -  a  Arithmetic exponentiation. Raises the second argument to the power\nof the first.  Math::pow(2, 3); // 3 ^ 2 = 9\nMath::pow(3, 2); // 2 ^ 3 = 8", 
            "title": "pow"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Math/#product", 
            "text": "Array Product  :: Number a =  [a] -  a  Returns the product of a list of numbers, i.e. the result of multiplying\nevery element of a list together. Returns 1 for an empty list.  Math::product([2, 2, 3]); // 12\nMath::product([]); // 1", 
            "title": "product"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Math/#range", 
            "text": "Number Range  :: Number a =  a -  a -  a  Given two values m and n, return all values between m and n in an array, inclusive, with a\nstep size of $step. The list of numbers will start at the first value and approach the second value.  Math::range(1, 1, 5); // [1, 2, 3, 4, 5]\nMath::range(2, 0, -3); // [0, -2]\nMath::range(0, 0, 0); // [0]\nMath::range(0.1, 0, 0.5); // [0, 0.1, 0.2, 0.3, 0.4, 0.5]", 
            "title": "range"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Math/#subtract", 
            "text": "Arithmetic Subtraction.  :: Number a =  a -  a -  a  Subtracts two numbers, with the first argument being subtracted from the second.  Math::subtract(4, 9); // 5\nMath::subtract(-1, 3); // 4", 
            "title": "subtract"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Math/#sum", 
            "text": "Array Sum  :: Number a =  [a] -  a  Add all the numbers of a list together and return their sum. If the given\nlist is empty, returns 0.  Math::sum([1, 2, 3]); // 6\nMath::sum([]); // 0", 
            "title": "sum"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Object/", 
            "text": "assign\n\n\nThis function is currently missing documentation.\n\n\n\n\ngetProp\n\n\nGet Property\n :: String -\n Obj a -\n mixed\n\n\nGets a property on the object\n\n\n$obj = new stdClass();\n$obj-\nvalue = 'hi!';\nObject::getValue('value', $obj); // 'hi!'\n\n\n\n\n\n\ninvokeMethod\n\n\nInvoke Method\n :: String -\n Obj a -\n mixed\n\n\nInvokes a method on the object\n\n\n$person = new stdObject(array(\n \nsayHi\n =\n function() {\n     return \nhi!\n;\n }\n));\nObject::invokeMethod('sayHi', $person); // 'hi!'\n\n\n\n\n\n\nisInstanceOf\n\n\nIs Instance Of\n :: String -\n Obj a -\n mixed\n\n\nChecks if the object is an instance of the specified class\n\n\nObject::isInstanceOf('stdClass', (new stdClass())); // true\n\n\n\n\n\n\nsetProp\n\n\nSet Property\n :: String -\n a -\n Obj a -\n Obj a\n\n\nSets a property on the object\n\n\nObject::setValue('value', new stdClass(), 'hi!');\n// object(stdClass)#1 (1) {\n//   [\nvalue\n]=\n\n//   string(3) \nhi!\n\n// }", 
            "title": "Object"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Object/#assign", 
            "text": "This function is currently missing documentation.", 
            "title": "assign"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Object/#getprop", 
            "text": "Get Property  :: String -  Obj a -  mixed  Gets a property on the object  $obj = new stdClass();\n$obj- value = 'hi!';\nObject::getValue('value', $obj); // 'hi!'", 
            "title": "getProp"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Object/#invokemethod", 
            "text": "Invoke Method  :: String -  Obj a -  mixed  Invokes a method on the object  $person = new stdObject(array(\n  sayHi  =  function() {\n     return  hi! ;\n }\n));\nObject::invokeMethod('sayHi', $person); // 'hi!'", 
            "title": "invokeMethod"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Object/#isinstanceof", 
            "text": "Is Instance Of  :: String -  Obj a -  mixed  Checks if the object is an instance of the specified class  Object::isInstanceOf('stdClass', (new stdClass())); // true", 
            "title": "isInstanceOf"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Object/#setprop", 
            "text": "Set Property  :: String -  a -  Obj a -  Obj a  Sets a property on the object  Object::setValue('value', new stdClass(), 'hi!');\n// object(stdClass)#1 (1) {\n//   [ value ]= \n//   string(3)  hi! \n// }", 
            "title": "setProp"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Strings/", 
            "text": "concat\n\n\nString Concatenation\n :: String -\n String -\n String\n\n\nConcatenates the first argument to the second argument, provided both arguments\nare strings. Defers to the PHP built-in concatenation.\n\n\nStrings::concat('as', 'df'); // 'dfas'\nStrings::concat('World', $concat('ello', 'H')); // 'HelloWorld'\n\n\n\n\n\n\njoin\n\n\nString Joining\n :: String -\n [String] -\n String\n\n\nJoins an array of strings together with a given delimiter. Works similarly\nto PHP \nimplode\n. The inverse of \nsplit\n.\n\n\nStrings::join(' ', ['Hello', 'World']); // 'Hello World'\nStrings::join('', ['a', 's', 'd', 'f']); // 'asdf'\n\n\n\n\n\n\nsplit\n\n\nString Splitting\n :: String -\n String -\n [String]\n\n\nSplit a string into parts based on a delimiter. Operates similar to php \nexplode\n,\nbut is more consistent. Can split on empty delimiters, and trims out empty strings\nafter exploding.\n\n\nStrings::split('-', 'Hello-World'); // ['Hello', 'World']\nStrings::split('', 'asdf'); // ['a', 's', 'd', 'f']\nStrings::split('-', 'foo-bar-'); ['foo', 'bar']\n\n\n\n\n\n\nstartsWith\n\n\nSubstring Match\n :: String -\n String -\n Bool\n\n\nDetermines if a string starts with a specific substring. Returns true if the string\nmatches the substring at its start, otherwise false.\n\n\nStrings::startsWith('as', 'asdf'); true\nStrings::startsWith('foo', 'barfoo'); false\n\n\n\n\n\n\ntoLowercase\n\n\nLowercase Conversion\n :: String -\n String\n\n\nConverts a string to lowercase.\n\n\nStrings::toLowercase('ASdf'); // 'asdf'\n\n\n\n\n\n\ntoUppercase\n\n\nUppercase Conversion\n :: String -\n String\n\n\nConverts a string to uppercase.\n\n\nStrings::toUppercase('asdf'); // 'ASDF'\n\n\n\n\n\n\ntrim\n\n\nTrim Whitespace\n :: String -\n String\n\n\nRemoves all leading and trailing whitespace from a string. Defers to\nPHP trim.\n\n\nStrings::trim(' asdf '); // 'asdf'", 
            "title": "Strings"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Strings/#concat", 
            "text": "String Concatenation  :: String -  String -  String  Concatenates the first argument to the second argument, provided both arguments\nare strings. Defers to the PHP built-in concatenation.  Strings::concat('as', 'df'); // 'dfas'\nStrings::concat('World', $concat('ello', 'H')); // 'HelloWorld'", 
            "title": "concat"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Strings/#join", 
            "text": "String Joining  :: String -  [String] -  String  Joins an array of strings together with a given delimiter. Works similarly\nto PHP  implode . The inverse of  split .  Strings::join(' ', ['Hello', 'World']); // 'Hello World'\nStrings::join('', ['a', 's', 'd', 'f']); // 'asdf'", 
            "title": "join"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Strings/#split", 
            "text": "String Splitting  :: String -  String -  [String]  Split a string into parts based on a delimiter. Operates similar to php  explode ,\nbut is more consistent. Can split on empty delimiters, and trims out empty strings\nafter exploding.  Strings::split('-', 'Hello-World'); // ['Hello', 'World']\nStrings::split('', 'asdf'); // ['a', 's', 'd', 'f']\nStrings::split('-', 'foo-bar-'); ['foo', 'bar']", 
            "title": "split"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Strings/#startswith", 
            "text": "Substring Match  :: String -  String -  Bool  Determines if a string starts with a specific substring. Returns true if the string\nmatches the substring at its start, otherwise false.  Strings::startsWith('as', 'asdf'); true\nStrings::startsWith('foo', 'barfoo'); false", 
            "title": "startsWith"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Strings/#tolowercase", 
            "text": "Lowercase Conversion  :: String -  String  Converts a string to lowercase.  Strings::toLowercase('ASdf'); // 'asdf'", 
            "title": "toLowercase"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Strings/#touppercase", 
            "text": "Uppercase Conversion  :: String -  String  Converts a string to uppercase.  Strings::toUppercase('asdf'); // 'ASDF'", 
            "title": "toUppercase"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Strings/#trim", 
            "text": "Trim Whitespace  :: String -  String  Removes all leading and trailing whitespace from a string. Defers to\nPHP trim.  Strings::trim(' asdf '); // 'asdf'", 
            "title": "trim"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Applicative/", 
            "text": "apply\n\n\nThis function is currently missing documentation.\n\n\n\n\nliftA2\n\n\nThis function is currently missing documentation.\n\n\n\n\nliftA3\n\n\nThis function is currently missing documentation.\n\n\n\n\npure\n\n\nThis function is currently missing documentation.", 
            "title": "Applicative"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Applicative/#apply", 
            "text": "This function is currently missing documentation.", 
            "title": "apply"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Applicative/#lifta2", 
            "text": "This function is currently missing documentation.", 
            "title": "liftA2"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Applicative/#lifta3", 
            "text": "This function is currently missing documentation.", 
            "title": "liftA3"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Applicative/#pure", 
            "text": "This function is currently missing documentation.", 
            "title": "pure"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Functor/", 
            "text": "extract\n\n\nThis function is currently missing documentation.\n\n\n\n\nfmap\n\n\nThis function is currently missing documentation.", 
            "title": "Functor"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Functor/#extract", 
            "text": "This function is currently missing documentation.", 
            "title": "extract"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Functor/#fmap", 
            "text": "This function is currently missing documentation.", 
            "title": "fmap"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Lens/", 
            "text": "constant\n\n\nThis function is currently missing documentation.\n\n\n\n\nidentity\n\n\nThis function is currently missing documentation.\n\n\n\n\nindexLens\n\n\nThis function is currently missing documentation.\n\n\n\n\nindexLensSafe\n\n\nThis function is currently missing documentation.\n\n\n\n\nkeLens\n\n\nThis function is currently missing documentation.\n\n\n\n\noverL\n\n\nThis function is currently missing documentation.\n\n\n\n\npathLens\n\n\nThis function is currently missing documentation.\n\n\n\n\npathLensSafe\n\n\nThis function is currently missing documentation.\n\n\n\n\npropLens\n\n\nThis function is currently missing documentation.\n\n\n\n\nsetL\n\n\nThis function is currently missing documentation.\n\n\n\n\nviewL\n\n\nView\n :: Lens a -\n a\n\n\nView an object or array through a lens. Simply applies your lens - the\nbehavior of this function will vary slightly depending on the particular\nlens that you're using.\n\n\n$myLens = Lens::indexLens('a');\nLens::viewL($myLens, ['a' =\n 'b']); // b", 
            "title": "Lens"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Lens/#constant", 
            "text": "This function is currently missing documentation.", 
            "title": "constant"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Lens/#identity", 
            "text": "This function is currently missing documentation.", 
            "title": "identity"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Lens/#indexlens", 
            "text": "This function is currently missing documentation.", 
            "title": "indexLens"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Lens/#indexlenssafe", 
            "text": "This function is currently missing documentation.", 
            "title": "indexLensSafe"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Lens/#kelens", 
            "text": "This function is currently missing documentation.", 
            "title": "keLens"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Lens/#overl", 
            "text": "This function is currently missing documentation.", 
            "title": "overL"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Lens/#pathlens", 
            "text": "This function is currently missing documentation.", 
            "title": "pathLens"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Lens/#pathlenssafe", 
            "text": "This function is currently missing documentation.", 
            "title": "pathLensSafe"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Lens/#proplens", 
            "text": "This function is currently missing documentation.", 
            "title": "propLens"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Lens/#setl", 
            "text": "This function is currently missing documentation.", 
            "title": "setL"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Lens/#viewl", 
            "text": "View  :: Lens a -  a  View an object or array through a lens. Simply applies your lens - the\nbehavior of this function will vary slightly depending on the particular\nlens that you're using.  $myLens = Lens::indexLens('a');\nLens::viewL($myLens, ['a' =  'b']); // b", 
            "title": "viewL"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Monad/", 
            "text": "bind\n\n\nThis function is currently missing documentation.\n\n\n\n\nkleisliCompose\n\n\nThis function is currently missing documentation.", 
            "title": "Monad"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Monad/#bind", 
            "text": "This function is currently missing documentation.", 
            "title": "bind"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Monad/#kleislicompose", 
            "text": "This function is currently missing documentation.", 
            "title": "kleisliCompose"
        }
    ]
}