{
    "docs": [
        {
            "location": "/", 
            "text": "Vector / Core\n\n\nPurpose\n\n\nVector gives your functions superpowers.\nIt lets you autoload your functions with Composer without having to mess with autoloading individual files.\nIt allows you to automatically curry your userland functions with zero effort on your part.\nIt provides built-in memoization for abstracting away time-consuming pure operations.\nIt gives you useful helpers for composing simple functions into more complex ones and gives you the building blocks you need to make data manipulation easier than ever, all while maintaining a simple and declarative module loading system so your dependencies are always clear and concise.\n\n\nPHP Version Support\n\n\n\n\n5.6 +\n\n\n\n\nShow Me Some Code\n\n\nAutoloading Functions? A snap.\n\n\nuse Vector\\Lib\\ArrayList;\n\n\n\n\nCurrying? Completely free.\n\n\n$addOne = ArrayList::map(function($a) { return $a + 1; });\n$addOne([1, 2, 3]); // [2, 3, 4]\n\n\n\n\nMemoization? Batteries included.\n\n\nClass MyFunctions extends Module {\n    protected $memoize = ['myFunction'];\n}\n\n\n\n\nComposition? No problem.\n\n\n$addSix = Lambda::compose(Math::add(4), Math::add(2));\n$addSix(4); // 10;", 
            "title": "Introduction"
        }, 
        {
            "location": "/#vector-core", 
            "text": "", 
            "title": "Vector / Core"
        }, 
        {
            "location": "/#purpose", 
            "text": "Vector gives your functions superpowers.\nIt lets you autoload your functions with Composer without having to mess with autoloading individual files.\nIt allows you to automatically curry your userland functions with zero effort on your part.\nIt provides built-in memoization for abstracting away time-consuming pure operations.\nIt gives you useful helpers for composing simple functions into more complex ones and gives you the building blocks you need to make data manipulation easier than ever, all while maintaining a simple and declarative module loading system so your dependencies are always clear and concise.", 
            "title": "Purpose"
        }, 
        {
            "location": "/#php-version-support", 
            "text": "5.6 +", 
            "title": "PHP Version Support"
        }, 
        {
            "location": "/#show-me-some-code", 
            "text": "Autoloading Functions? A snap.  use Vector\\Lib\\ArrayList;  Currying? Completely free.  $addOne = ArrayList::map(function($a) { return $a + 1; });\n$addOne([1, 2, 3]); // [2, 3, 4]  Memoization? Batteries included.  Class MyFunctions extends Module {\n    protected $memoize = ['myFunction'];\n}  Composition? No problem.  $addSix = Lambda::compose(Math::add(4), Math::add(2));\n$addSix(4); // 10;", 
            "title": "Show Me Some Code"
        }, 
        {
            "location": "/user-guide/basics/", 
            "text": "Functional Basics\n\n\nFirst of all, what is functional programming?\n\n\n\n\nIn computer science, functional programming is a programming paradigm that treats computation\nas the evaluation of mathematical functions and avoids changing-state and mutable data.\n\n\n\n\nVector is a functional programming library that follows this credo and implements helpers and utilities\nthat allow you to do the same in your own code.\n\n\nBefore we get started, here's some things to know:\n\n\nFunction Declaration vs. Function Expression\n\n\nYou're probably very familiar with functions in PHP. But what you might not know is that there are\nmultiple ways to declare functions in PHP. The first is a declaration, where a function name is placed\ninto a function table keyed to its name and accessible globally (so long as it's loaded). The second method is\na function expression, where a function is placed into the PHP Closure object and stored in a scoped variable.\n\n\n// Function Declaration\nfunction add($a, $b) {\n    return $a + $b;\n}\n\n// Function Expression\n$add = function($a, $b) {\n    return $a + $b;\n}\n\n\n\n\nWe can use a function expression in the same way we use a regular function:\n\n\n$add(1, 2); // Returns 3\n\n\n\n\nVector makes exclusive use of function expressions, both for consistency when combining functions together\nand for their scoped nature.\n\n\nUsing Vector Functions\n\n\nFunctions in Vector are organized into modules, which each have some related functionality or 'theme.' Simply call the function\nyou want to use as though it were a normal static function on the module in question.\n\n\nFor instance, if we want to use in the Vector wrapper function for \ncount\n called \nlength\n from the \nArrayList\n module, we would\nwrite:\n\n\nVector\\Lib\\ArrayList::length([1, 2, 3]); // 3\n\n\n\n\nIf you look at the ArrayList class in Vector\\Lib, you'll notice that there is not actually a \nlength\n function defined anywhere. Rather, there's a \n__length\n\nfunction that looks something like this:\n\n\nprotected static function __length($list)\n{\n    return count($list);\n}\n\n\n\n\nThe function module intercepts calls to static functions on a module and performs a set of operations under the hood and completely transparently. We'll\ngo into more detail about how this is implemented, and more importantly, how you can implement your own modules in the 'Module' section.\n\n\nIt's important to note that calling a function on a module with no arguments will return a closure that executes the requested function\nwhen invoked. For instance:\n\n\n$length = Vector\\Lib\\ArrayList::length();\n$length([1, 2, 3]); // 3\n\n\n\n\nAt first this may seem strange, but it's actually both intended and useful -- and a direct consequence of currying, which will we discuss next.\n\n\nCurrying\n\n\nCurrying is the act of modifying a function in such a way that it can accept its arguments in chunks. A curried function\ndoesn't have to be supplied all of its arguments in order to have some effect.\n\n\nSay we have a function that adds two numbers together.\n\n\n$add = function($a, $b) {\n    return $a + $b;\n}\n\n\n\n\nWhen we want to use add, we have to supply it two arguments, \n$a\n and \n$b\n. But say we want to give it is first argument,\ngo do something else, then come back and give it its second argument. We can curry the \n$add\n function to allow us to do this.\n\n\n$addCurried = function($a) {\n    return function($b) use ($a) {\n        return $a + $b;\n    }\n}\n\n\n\n\nNow we can use the \n$add\n function like this:\n\n\n$addNow = $addCurried(1); // $addNow = curried PHP closure\n$addLater = $addNow(2);   // $addLater = 3;\n\n\n\n\nWhy in the world would we ever want to do this? Currying in and of itself doesn't give us much,\nbut it has a powerful consequence: Partial Application.\n\n\nPartial Application\n\n\nNotice in the previous example how we stored the interim result of giving the first argument to our curried \n$add\n function in a local variable\ncalled \n$addNow\n. This variable is a function expression, and it can be used in the same way as any other function. The first argument we've given\nit has been closed over, and this is now a completely new function with different behaviors from \n$add\n. Let's rename it to \n$increment\n and see how it behaves:\n\n\n$increment = $addCurried(1);\n\n$increment(2); // 3\n$increment(0); // 1\n$increment(9); // 10\n\n\n\n\nWe've taken our \n$add\n function and created an increment function, without writing a single line of code aside from applying the first argument. We can create an infinite\nnumber of \n$addX\n functions in exactly the same way.\n\n\nAll functions in Vector are curried by default, so they can all be partially applied. This is why calling a Vector function with no arguments returns that function as a closure\nas we discussed in the \nUsing Vector Functions\n section.\n\n\nComposition\n\n\nWe've now seen how we can create functions from other functions by partially applying them. But there are other ways to create new functions from small components.\nWe can also compose them together, which is like creating a chain of steps for a function to step through, from beginning to end.\n\n\nVector provides a \ncompose\n function in the Lambda module which we can pull in and play around with. \ncompose\n takes its arguments and applies them sequentially from\nback to front -- provided every argument is a function.\n\n\nLet's say we want to create a function that converts from celcius to fahrenheit, and that we've already implmented the basic mathematical functions like\nadd, subtract, multiply, and divide. We can use \ncompose\n to chain all these calculations together to create a \ntoFahrenheit\n function:\n\n\n// Let's assume we have an $add and $multiply function. The Math module\n// provies these, but we'll just assume we have them in locally scoped closure objects.\n\n// Notice that compose returns a function.\n// In PHP 7+ you can invoke it immediately using Lambda::compose(...)($arg)\n$toFahrenheit = Lambda::compose(\n    $add(32),\n    $multiply(9/5)\n);\n\n$toFahrenheit(8); // Returns 46.4\n\n\n\n\nNotice how \ncompose\n reads: We first perform the operation last in the list, then move backward to the front of the list. This is laid out to match the mathematical definition\nof compose: \n(f \u2218 g)(x) = f(g(x))\n. If you can't wrap your head around the backwards nature, Vector also supplied a \npipe\n function on the Lambda module that acts as compose\nfrom front-to-back.\n\n\nNotice also how we used partial application to create helper functions from \n$add\n and \n$multiply\n. Partial application and composition\ncan be mixed and matched to create more complex functions from very simple components.\n\n\nLifting\n\n\nLet's use our \n$toFahrenheit\n function from before, but imagine instead that we want to apply it to a list of temperatures. Instead of looping over the\nlist in a procedural way, let's use \nmap\n from the ArrayList module.\n\n\n// Our list of temperatures\n$data = [50.0, 176.0, 212.0];\n\nArrayList::map($toFahrenheit, $data); // Returns [10, 80, 100]\n\n\n\n\nIf you've ever used PHP's \narray_map\n before, you should recognize what's going on. \nmap\n is taking a function with one input and one output, and sequentially\napplying it to every element in an array.\n\n\nHowever, \nmap\n is a function just like any other - it's curried, and it can be partially applied. If we partially apply \nmap\n, we've created a new function that now operates\non a list as opposed to a single element. We've lifted it from one domain to another. Let's see how we can use this in conjunction with partial application and composition, putting\nit all together.\n\n\nSay we have a set of temperature data from a weather API, but it's not the highest quality -- The values it gives us are one degree lower than they should be.\nOur task is to calculate the mean temperature from the temperature data after correcting the values by shifting\nthem one degree higher.\n\n\n// The Math module provides a mean function, and we're using $add and $toFahrenheit from above\n$correctedMeanTemp = Lambda::compose(\n    Math::mean(),\n    ArrayList::map(\n        Lambda::compose($toFahrenheit, $add(1))\n    )\n);\n\n\n\n\nNotice how we have created a function to complete our task without even bothering to load our data in - we don't need it. Our function will first\nadd one to every element in the dataset and then convert it to fahrenheit, then pass that mapped array to our mean function. This is called the point-free style.\n\n\nNow we can take our \n$correctedMeanTemp\n and add it to our own Vector module and use it throughout our codebase whenever we need to work with temperature data.\n\n\nIn the next section, we'll go over the Vector Module - how it works, and how you can make your own.", 
            "title": "Functional Basics"
        }, 
        {
            "location": "/user-guide/basics/#functional-basics", 
            "text": "First of all, what is functional programming?   In computer science, functional programming is a programming paradigm that treats computation\nas the evaluation of mathematical functions and avoids changing-state and mutable data.   Vector is a functional programming library that follows this credo and implements helpers and utilities\nthat allow you to do the same in your own code.  Before we get started, here's some things to know:", 
            "title": "Functional Basics"
        }, 
        {
            "location": "/user-guide/basics/#function-declaration-vs-function-expression", 
            "text": "You're probably very familiar with functions in PHP. But what you might not know is that there are\nmultiple ways to declare functions in PHP. The first is a declaration, where a function name is placed\ninto a function table keyed to its name and accessible globally (so long as it's loaded). The second method is\na function expression, where a function is placed into the PHP Closure object and stored in a scoped variable.  // Function Declaration\nfunction add($a, $b) {\n    return $a + $b;\n}\n\n// Function Expression\n$add = function($a, $b) {\n    return $a + $b;\n}  We can use a function expression in the same way we use a regular function:  $add(1, 2); // Returns 3  Vector makes exclusive use of function expressions, both for consistency when combining functions together\nand for their scoped nature.", 
            "title": "Function Declaration vs. Function Expression"
        }, 
        {
            "location": "/user-guide/basics/#using-vector-functions", 
            "text": "Functions in Vector are organized into modules, which each have some related functionality or 'theme.' Simply call the function\nyou want to use as though it were a normal static function on the module in question.  For instance, if we want to use in the Vector wrapper function for  count  called  length  from the  ArrayList  module, we would\nwrite:  Vector\\Lib\\ArrayList::length([1, 2, 3]); // 3  If you look at the ArrayList class in Vector\\Lib, you'll notice that there is not actually a  length  function defined anywhere. Rather, there's a  __length \nfunction that looks something like this:  protected static function __length($list)\n{\n    return count($list);\n}  The function module intercepts calls to static functions on a module and performs a set of operations under the hood and completely transparently. We'll\ngo into more detail about how this is implemented, and more importantly, how you can implement your own modules in the 'Module' section.  It's important to note that calling a function on a module with no arguments will return a closure that executes the requested function\nwhen invoked. For instance:  $length = Vector\\Lib\\ArrayList::length();\n$length([1, 2, 3]); // 3  At first this may seem strange, but it's actually both intended and useful -- and a direct consequence of currying, which will we discuss next.", 
            "title": "Using Vector Functions"
        }, 
        {
            "location": "/user-guide/basics/#currying", 
            "text": "Currying is the act of modifying a function in such a way that it can accept its arguments in chunks. A curried function\ndoesn't have to be supplied all of its arguments in order to have some effect.  Say we have a function that adds two numbers together.  $add = function($a, $b) {\n    return $a + $b;\n}  When we want to use add, we have to supply it two arguments,  $a  and  $b . But say we want to give it is first argument,\ngo do something else, then come back and give it its second argument. We can curry the  $add  function to allow us to do this.  $addCurried = function($a) {\n    return function($b) use ($a) {\n        return $a + $b;\n    }\n}  Now we can use the  $add  function like this:  $addNow = $addCurried(1); // $addNow = curried PHP closure\n$addLater = $addNow(2);   // $addLater = 3;  Why in the world would we ever want to do this? Currying in and of itself doesn't give us much,\nbut it has a powerful consequence: Partial Application.", 
            "title": "Currying"
        }, 
        {
            "location": "/user-guide/basics/#partial-application", 
            "text": "Notice in the previous example how we stored the interim result of giving the first argument to our curried  $add  function in a local variable\ncalled  $addNow . This variable is a function expression, and it can be used in the same way as any other function. The first argument we've given\nit has been closed over, and this is now a completely new function with different behaviors from  $add . Let's rename it to  $increment  and see how it behaves:  $increment = $addCurried(1);\n\n$increment(2); // 3\n$increment(0); // 1\n$increment(9); // 10  We've taken our  $add  function and created an increment function, without writing a single line of code aside from applying the first argument. We can create an infinite\nnumber of  $addX  functions in exactly the same way.  All functions in Vector are curried by default, so they can all be partially applied. This is why calling a Vector function with no arguments returns that function as a closure\nas we discussed in the  Using Vector Functions  section.", 
            "title": "Partial Application"
        }, 
        {
            "location": "/user-guide/basics/#composition", 
            "text": "We've now seen how we can create functions from other functions by partially applying them. But there are other ways to create new functions from small components.\nWe can also compose them together, which is like creating a chain of steps for a function to step through, from beginning to end.  Vector provides a  compose  function in the Lambda module which we can pull in and play around with.  compose  takes its arguments and applies them sequentially from\nback to front -- provided every argument is a function.  Let's say we want to create a function that converts from celcius to fahrenheit, and that we've already implmented the basic mathematical functions like\nadd, subtract, multiply, and divide. We can use  compose  to chain all these calculations together to create a  toFahrenheit  function:  // Let's assume we have an $add and $multiply function. The Math module\n// provies these, but we'll just assume we have them in locally scoped closure objects.\n\n// Notice that compose returns a function.\n// In PHP 7+ you can invoke it immediately using Lambda::compose(...)($arg)\n$toFahrenheit = Lambda::compose(\n    $add(32),\n    $multiply(9/5)\n);\n\n$toFahrenheit(8); // Returns 46.4  Notice how  compose  reads: We first perform the operation last in the list, then move backward to the front of the list. This is laid out to match the mathematical definition\nof compose:  (f \u2218 g)(x) = f(g(x)) . If you can't wrap your head around the backwards nature, Vector also supplied a  pipe  function on the Lambda module that acts as compose\nfrom front-to-back.  Notice also how we used partial application to create helper functions from  $add  and  $multiply . Partial application and composition\ncan be mixed and matched to create more complex functions from very simple components.", 
            "title": "Composition"
        }, 
        {
            "location": "/user-guide/basics/#lifting", 
            "text": "Let's use our  $toFahrenheit  function from before, but imagine instead that we want to apply it to a list of temperatures. Instead of looping over the\nlist in a procedural way, let's use  map  from the ArrayList module.  // Our list of temperatures\n$data = [50.0, 176.0, 212.0];\n\nArrayList::map($toFahrenheit, $data); // Returns [10, 80, 100]  If you've ever used PHP's  array_map  before, you should recognize what's going on.  map  is taking a function with one input and one output, and sequentially\napplying it to every element in an array.  However,  map  is a function just like any other - it's curried, and it can be partially applied. If we partially apply  map , we've created a new function that now operates\non a list as opposed to a single element. We've lifted it from one domain to another. Let's see how we can use this in conjunction with partial application and composition, putting\nit all together.  Say we have a set of temperature data from a weather API, but it's not the highest quality -- The values it gives us are one degree lower than they should be.\nOur task is to calculate the mean temperature from the temperature data after correcting the values by shifting\nthem one degree higher.  // The Math module provides a mean function, and we're using $add and $toFahrenheit from above\n$correctedMeanTemp = Lambda::compose(\n    Math::mean(),\n    ArrayList::map(\n        Lambda::compose($toFahrenheit, $add(1))\n    )\n);  Notice how we have created a function to complete our task without even bothering to load our data in - we don't need it. Our function will first\nadd one to every element in the dataset and then convert it to fahrenheit, then pass that mapped array to our mean function. This is called the point-free style.  Now we can take our  $correctedMeanTemp  and add it to our own Vector module and use it throughout our codebase whenever we need to work with temperature data.  In the next section, we'll go over the Vector Module - how it works, and how you can make your own.", 
            "title": "Lifting"
        }, 
        {
            "location": "/user-guide/module/", 
            "text": "The Vector Module\n\n\nThe Vector Module exists in the \nVector\\Core\n namespace, and every Vector module\nexists as a subclass of the Module. \nModule\n provides loads of benefits transparently, and\nstrives to be as simple as possible to implement.\n\n\nWhat it Does\n\n\nThe primary benefit of \nModule\n is that it will automatically curry the functions placed\ninside of it. This allows you to write your functions without worrying about manually\nadding the breakpoints for currying, or worrying about closing over curried arguments -- You can\nsimply write your function as through it receives all of its arguments at once, and let \nModule\n\nhandle the rest.\n\n\nThe \nModule\n also provides mechanisms for memoization -- caching function calls for long-running\nor expensive operations -- transparently and automatically.\n\n\nA side benefit of \nModule\n is that it allows you to autoload your functions with Composer.\nWhile later versions of PHP have namespaced functions, there is currently no way to autoload\nthem in Composer aside from using the \nautoload.files\n field in the \ncomposer.json\n file, which\nloads the file on every request regardless of whether or not it's needed.\n\n\nImplementing Your Own Module\n\n\nCreating the Module\n\n\nTo implement your own \nModule\n, simply create a new class and extend \nVector\\Core\\Module\n:\n\n\nclass MyModule extends Vector\\Core\\Module\n{\n}\n\n\n\n\nAdding Functions\n\n\nThe Module will intercept function calls using the \n__callStatic\n magic method from PHP. Because of this though,\nthe name of your function can't match the name that you call from your code. We choose to adopt the magic method standard and\ndeclare all of our functions with double underscores prefixed to their names.\n\n\nclass MyModule extends Vector\\Core\\Module\n{\n    protected static __myFunction($a, $b)\n    {\n        return $a . ' foo ' . $b;\n    }\n}\n\n\n\n\nRecommended practice is to declare the functions in a module as \nprotected\n. The functions \ncannot\n be \nprivate\n because the parent class \nModule\n needs\nto be able to access them. They \ncan\n be \npublic\n however, but it's best not to provide a way to call your raw function without passing it through the\n\nModule\n proxy.\n\n\nEnabling Memoization\n\n\nMemoized functions store the result of their execution in a private context, and can then short circuit their execution and return their result\nif called again with the same arguments. This is effectively free caching.\n\n\n\n\nImportant\n\n\nMemoization assumes that your functions are pure. If your functions have side effects, those side effects will not execute again\nif you memoize the function causing them! Avoid side effects!\n\n\n\n\nMemoization is disabled for new modules by default -- you must opt into it. To enable memoization for a single or multiple functions, override\nthe \n$memoize\n field on your module:\n\n\nclass MyModule extends Vector\\Core\\Module\n{\n    protected static $memoize = ['myFunction'];\n\n    protected static __myFunction($a, $b)\n    {\n        return $a . ' foo ' . $b;\n    }\n}\n\n\n\n\nAlternatively, to enable memoization for an entire module, set \n$memoize\n to \ntrue\n.\n\n\nNotice how we declared the function in our \n$memoize\n list -- we do not include the double underscore prefix of the function name. The \nModule\n\ntakes care of interpreting that for us. Just list your function names with their display names, or the names you would use when using them.\n\n\nDisabling Currying\n\n\nIf you for some reason don't want your function to be curried, you can override the\n\n$doNotCurry\n field on your module:\n\n\nclass MyModule extends Vector\\Core\\Module\n{\n    protected static $doNotCurry = ['myFunction'];\n\n    protected static __myFunction($a, $b)\n    {\n        return $a . ' foo ' . $b;\n    }\n}\n\n\n\n\nAlternatively, to disable currying for an entire module, set \n$doNotCurry\n to \ntrue\n.\n\n\nNotice again that we don't include the double underscore in the \n$doNotCurry\n array.\n\n\nGenerally speaking you should never need to do this. This exists as a side effect of the internal\ncurry implementation and is exposed only for any edge cases where you might need it.", 
            "title": "Vector Modules"
        }, 
        {
            "location": "/user-guide/module/#the-vector-module", 
            "text": "The Vector Module exists in the  Vector\\Core  namespace, and every Vector module\nexists as a subclass of the Module.  Module  provides loads of benefits transparently, and\nstrives to be as simple as possible to implement.", 
            "title": "The Vector Module"
        }, 
        {
            "location": "/user-guide/module/#what-it-does", 
            "text": "The primary benefit of  Module  is that it will automatically curry the functions placed\ninside of it. This allows you to write your functions without worrying about manually\nadding the breakpoints for currying, or worrying about closing over curried arguments -- You can\nsimply write your function as through it receives all of its arguments at once, and let  Module \nhandle the rest.  The  Module  also provides mechanisms for memoization -- caching function calls for long-running\nor expensive operations -- transparently and automatically.  A side benefit of  Module  is that it allows you to autoload your functions with Composer.\nWhile later versions of PHP have namespaced functions, there is currently no way to autoload\nthem in Composer aside from using the  autoload.files  field in the  composer.json  file, which\nloads the file on every request regardless of whether or not it's needed.", 
            "title": "What it Does"
        }, 
        {
            "location": "/user-guide/module/#implementing-your-own-module", 
            "text": "", 
            "title": "Implementing Your Own Module"
        }, 
        {
            "location": "/user-guide/module/#creating-the-module", 
            "text": "To implement your own  Module , simply create a new class and extend  Vector\\Core\\Module :  class MyModule extends Vector\\Core\\Module\n{\n}", 
            "title": "Creating the Module"
        }, 
        {
            "location": "/user-guide/module/#adding-functions", 
            "text": "The Module will intercept function calls using the  __callStatic  magic method from PHP. Because of this though,\nthe name of your function can't match the name that you call from your code. We choose to adopt the magic method standard and\ndeclare all of our functions with double underscores prefixed to their names.  class MyModule extends Vector\\Core\\Module\n{\n    protected static __myFunction($a, $b)\n    {\n        return $a . ' foo ' . $b;\n    }\n}  Recommended practice is to declare the functions in a module as  protected . The functions  cannot  be  private  because the parent class  Module  needs\nto be able to access them. They  can  be  public  however, but it's best not to provide a way to call your raw function without passing it through the Module  proxy.", 
            "title": "Adding Functions"
        }, 
        {
            "location": "/user-guide/module/#enabling-memoization", 
            "text": "Memoized functions store the result of their execution in a private context, and can then short circuit their execution and return their result\nif called again with the same arguments. This is effectively free caching.   Important  Memoization assumes that your functions are pure. If your functions have side effects, those side effects will not execute again\nif you memoize the function causing them! Avoid side effects!   Memoization is disabled for new modules by default -- you must opt into it. To enable memoization for a single or multiple functions, override\nthe  $memoize  field on your module:  class MyModule extends Vector\\Core\\Module\n{\n    protected static $memoize = ['myFunction'];\n\n    protected static __myFunction($a, $b)\n    {\n        return $a . ' foo ' . $b;\n    }\n}  Alternatively, to enable memoization for an entire module, set  $memoize  to  true .  Notice how we declared the function in our  $memoize  list -- we do not include the double underscore prefix of the function name. The  Module \ntakes care of interpreting that for us. Just list your function names with their display names, or the names you would use when using them.", 
            "title": "Enabling Memoization"
        }, 
        {
            "location": "/user-guide/module/#disabling-currying", 
            "text": "If you for some reason don't want your function to be curried, you can override the $doNotCurry  field on your module:  class MyModule extends Vector\\Core\\Module\n{\n    protected static $doNotCurry = ['myFunction'];\n\n    protected static __myFunction($a, $b)\n    {\n        return $a . ' foo ' . $b;\n    }\n}  Alternatively, to disable currying for an entire module, set  $doNotCurry  to  true .  Notice again that we don't include the double underscore in the  $doNotCurry  array.  Generally speaking you should never need to do this. This exists as a side effect of the internal\ncurry implementation and is exposed only for any edge cases where you might need it.", 
            "title": "Disabling Currying"
        }, 
        {
            "location": "/advanced/lenses/", 
            "text": "Lenses\n\n\nLenses are both the most complicated and most powerful tool provided by Vector, offering a potent method of operating on\ndense or complex data structures. On this page we'll be going through what they are, how they work,\nand how to use them.\n\n\nLenses are provided in the Vector\\Control\\Lens module.\n\n\nWhat is a Lens\n\n\nIn the simplest terms, a lens is a function that acts as both a getter and a setter. It is a partially applied function that encodes a location or path to a\nspecific part of an object. We describe a lens as \"focusing\" on a particular section of an object or array, and we operate on the data by applying\na function at the focused point.\n\n\nLet's consider an example piece of data:\n\n\n$data = [\n    'name' =\n 'Joseph',\n    'code' =\n [\n        'library' =\n 'Vector'\n    ]\n];\n\n\n\n\nNow let's create a lens that focuses on the \nname\n index of an array.\n\n\n$nameLens = Lens::indexLens('name');\n\n\n\n\nWe now have a lens that is pointed at the \nname\n index of a key/value array. We can now use it to manipulate our data.\n\n\nUsing Lenses\n\n\nGetting Values with Lenses\n\n\nLet's see how a lens works as a getter. We already have a lens focusing on the \nname\n index of a piece of data. To use this lens\nto retrieve data, we need to invoke it as a getter. The \nLens\n module provides the \nviewL\n function to do this, short for \"View Through Lens\":\n\n\n$name = Lens::viewL($nameLens, $data); // 'Joseph'\n\n\n\n\nviewL\n expects a lens as the first argument, and the data set to invoke the lens on as the second argument. We can interpret this function call\nas \"Viewing the $data object through the $nameLens.\"\n\n\nSetting Values with Lenses\n\n\nWe've seen how lenses act as getters, now let's use them as setters. We'll need to invoke the lens as a setter, and the \nLens\n module provides\nthe \nsetL\n function (short for \"Set Through Lens\") to do just that.\n\n\n$result = Lens::setL($nameLens, 'Logan', $data);\n\n\n\n\nThis call results in \n$result\n being:\n\n\n[\n    'name' =\n 'Logan',\n    'code' =\n [\n        'library' =\n 'Vector'\n    ]\n]\n\n\n\n\nsetL\n takes the lens as the first argument, the value to set the focused position to as the second argument, and the object to manipulate through the lens\nas the third argument.\n\n\nUnlike setting a property directly through PHP, the \nsetL\n function has an extremely important property: \nIt is immutable.\n When we call \nsetL\n on the \n$data\n object\nand get the result, the \n$data\n object is \nnot\n changed.\n\n\nMutating Values with Lenses\n\n\nLenses actually provide a third execution context which is a combination of getting and setting. For example, if we want to modify a value in the original \n$data\n structure\nwhile simultaneously returning its entire contents, we can use the \noverL\n function, which is short for \"Execute Over Lens.\" This function executes a lambda expression over\nthe focus of the lens and returns the modified data structure.\n\n\nLet's say we want to append my last name to the \nname\n field in the original data structure:\n\n\n$addLastName = function($firstName) {\n    return $firstName . ' Walker';\n};\n\n$result = Lens::overL($nameLens, $addLastName, $data);\n\n\n\n\nWhich results in:\n\n\n[\n    'name' =\n 'Joseph Walker',\n    'code' =\n [\n        'library' =\n 'Vector'\n    ]\n]\n\n\n\n\nThe \noverL\n function still takes as lens as its first argument and the object to modify as the last, but now takes a function as the second argument. \noverL\n\nwill run this function over whatever the lens is focusing on and return the entirety of the data structure with the changes applied.\n\n\nNote that just like \nsetL\n, \noverL\n is \nimmutable\n. The original data is not changed.\n\n\nCombining Lenses\n\n\nLet's say now that we want to pull the \nlibrary\n field from the \n$data\n object. Let's write a naive solution to this problem using only what\nwe've learned so far about lenses:\n\n\nLens::viewL(Lens::indexLens('library'), Lens::viewL(Lens::indexLens('code'), $data)); // 'Vector'\n\n\n\n\nThis certainly works, but let's take it a step further. We know that lenses are functions, we just execute them in special ways.\n\n\nHowever, we also know that functions can be composed. This is where lenses really start to shine: \nLenses can be composed.\n\n\n$codeLens = Lambda::compose(\n    Lens::indexLens('code'),\n    Lens::indexLens('library')\n);\n\n\n\n\nNow we can use this lens to view the \nlibrary\n property just like before:\n\n\nLens::viewL($codeLens, $data); // 'Vector'\n\n\n\n\nThis composed lens operates \nexactly\n like the basic lenses we were working with before. We can use it to set values, and operate over values.\n\n\nLens::setL($codeLens, 'PHP', $data);\nLens::overL($codeLens, Strings::append('Lib'), $data);\n\n\n\n\nAdvanced Example\n\n\nNow that we know the basics of lenses, let's see how to use them in a more complex scenario:\n\n\n$someApiResponse = [\n    \nmeta\n =\n [\n        \ninfo\n =\n \nAn API Request Example\n\n    ],\n    \ndata\n =\n [\n        \nusers\n =\n [\n            [\n                \nname\n =\n \nJoseph\n,\n                \nfavorites\n =\n [\n                    \ncolors\n =\n [\n                        \nblue\n,\n                        \ngreen\n\n                    ],\n                    \nfoods\n =\n [\n                        \npho\n,\n                        \nfajitas\n\n                    ]\n                ]\n            ],\n            [\n                \nname\n =\n \nLogan\n,\n                \nfavorites\n =\n [\n                    \ncolors\n =\n [\n                        \nred\n\n                    ],\n                    \nfoods\n =\n [\n                        \nhamburgers\n,\n                        \ncurry\n\n                    ]\n                ]\n            ]\n        ]\n    ]\n]\n\n\n\n\nLet's do some things with this data set using lenses.\n\n\nCan you paint with all the colors of the API?\n\n\nBy combining several \nArrayList\n functions and \nviewL\n, we can gather up all the colors in our data set.\n\n\n// The Lens::pathLens() function let's us shortcut explicitly composing lenses by doing it for us.\n// We just supply an array of index strings.\n$colorsLens = Lens::pathLens(['favorites', 'colors']);\n\n$colors = ArrayList::flatten(\n    ArrayList::map(Lens::viewL($colorsLens), $someApiResponse['data']['users'])\n);\n\n\n\n\nEverybody likes tacos\n\n\nLet's use the \noverL\n function to append \"tacos\" to everyone's favorite foods.\n\n\n$usersLens = Lens::pathLens(['data', 'users']);\n$foodsLens = Lens::pathLens(['favorites', 'foods']);\n\n$withTacos = Lens::overL(\n    $usersLens,\n    ArrayList::map(\n        Lens::overL($foodLens, ArrayList::cons('tacos'))\n    ),\n    $someApiResponse\n);\n\n\n\n\nTag, you're it\n\n\nLet's say we want to tag a timestamp field of our response in the \nmeta\n block. We're going to use a special type of lens here\ncalled a \nsafe\n lens. This is a lens that can point to properties that technically don't have to exist. You can see the details\nfor this lens in the Lens API Documentation.\n\n\n// We're point to meta.timestamp here, which doesn't exist! But that's okay,\n// because we're using a safe lens.\n$timestampLens = Lens::pathLensSafe(['meta', 'timestamp']);\n\n$withTimestamps = Lens::setL(\n    $timestampLens,\n    time(),\n    $someApiResponse\n);", 
            "title": "Lenses"
        }, 
        {
            "location": "/advanced/lenses/#lenses", 
            "text": "Lenses are both the most complicated and most powerful tool provided by Vector, offering a potent method of operating on\ndense or complex data structures. On this page we'll be going through what they are, how they work,\nand how to use them.  Lenses are provided in the Vector\\Control\\Lens module.", 
            "title": "Lenses"
        }, 
        {
            "location": "/advanced/lenses/#what-is-a-lens", 
            "text": "In the simplest terms, a lens is a function that acts as both a getter and a setter. It is a partially applied function that encodes a location or path to a\nspecific part of an object. We describe a lens as \"focusing\" on a particular section of an object or array, and we operate on the data by applying\na function at the focused point.  Let's consider an example piece of data:  $data = [\n    'name' =  'Joseph',\n    'code' =  [\n        'library' =  'Vector'\n    ]\n];  Now let's create a lens that focuses on the  name  index of an array.  $nameLens = Lens::indexLens('name');  We now have a lens that is pointed at the  name  index of a key/value array. We can now use it to manipulate our data.", 
            "title": "What is a Lens"
        }, 
        {
            "location": "/advanced/lenses/#using-lenses", 
            "text": "", 
            "title": "Using Lenses"
        }, 
        {
            "location": "/advanced/lenses/#getting-values-with-lenses", 
            "text": "Let's see how a lens works as a getter. We already have a lens focusing on the  name  index of a piece of data. To use this lens\nto retrieve data, we need to invoke it as a getter. The  Lens  module provides the  viewL  function to do this, short for \"View Through Lens\":  $name = Lens::viewL($nameLens, $data); // 'Joseph'  viewL  expects a lens as the first argument, and the data set to invoke the lens on as the second argument. We can interpret this function call\nas \"Viewing the $data object through the $nameLens.\"", 
            "title": "Getting Values with Lenses"
        }, 
        {
            "location": "/advanced/lenses/#setting-values-with-lenses", 
            "text": "We've seen how lenses act as getters, now let's use them as setters. We'll need to invoke the lens as a setter, and the  Lens  module provides\nthe  setL  function (short for \"Set Through Lens\") to do just that.  $result = Lens::setL($nameLens, 'Logan', $data);  This call results in  $result  being:  [\n    'name' =  'Logan',\n    'code' =  [\n        'library' =  'Vector'\n    ]\n]  setL  takes the lens as the first argument, the value to set the focused position to as the second argument, and the object to manipulate through the lens\nas the third argument.  Unlike setting a property directly through PHP, the  setL  function has an extremely important property:  It is immutable.  When we call  setL  on the  $data  object\nand get the result, the  $data  object is  not  changed.", 
            "title": "Setting Values with Lenses"
        }, 
        {
            "location": "/advanced/lenses/#mutating-values-with-lenses", 
            "text": "Lenses actually provide a third execution context which is a combination of getting and setting. For example, if we want to modify a value in the original  $data  structure\nwhile simultaneously returning its entire contents, we can use the  overL  function, which is short for \"Execute Over Lens.\" This function executes a lambda expression over\nthe focus of the lens and returns the modified data structure.  Let's say we want to append my last name to the  name  field in the original data structure:  $addLastName = function($firstName) {\n    return $firstName . ' Walker';\n};\n\n$result = Lens::overL($nameLens, $addLastName, $data);  Which results in:  [\n    'name' =  'Joseph Walker',\n    'code' =  [\n        'library' =  'Vector'\n    ]\n]  The  overL  function still takes as lens as its first argument and the object to modify as the last, but now takes a function as the second argument.  overL \nwill run this function over whatever the lens is focusing on and return the entirety of the data structure with the changes applied.  Note that just like  setL ,  overL  is  immutable . The original data is not changed.", 
            "title": "Mutating Values with Lenses"
        }, 
        {
            "location": "/advanced/lenses/#combining-lenses", 
            "text": "Let's say now that we want to pull the  library  field from the  $data  object. Let's write a naive solution to this problem using only what\nwe've learned so far about lenses:  Lens::viewL(Lens::indexLens('library'), Lens::viewL(Lens::indexLens('code'), $data)); // 'Vector'  This certainly works, but let's take it a step further. We know that lenses are functions, we just execute them in special ways.  However, we also know that functions can be composed. This is where lenses really start to shine:  Lenses can be composed.  $codeLens = Lambda::compose(\n    Lens::indexLens('code'),\n    Lens::indexLens('library')\n);  Now we can use this lens to view the  library  property just like before:  Lens::viewL($codeLens, $data); // 'Vector'  This composed lens operates  exactly  like the basic lenses we were working with before. We can use it to set values, and operate over values.  Lens::setL($codeLens, 'PHP', $data);\nLens::overL($codeLens, Strings::append('Lib'), $data);", 
            "title": "Combining Lenses"
        }, 
        {
            "location": "/advanced/lenses/#advanced-example", 
            "text": "Now that we know the basics of lenses, let's see how to use them in a more complex scenario:  $someApiResponse = [\n     meta  =  [\n         info  =   An API Request Example \n    ],\n     data  =  [\n         users  =  [\n            [\n                 name  =   Joseph ,\n                 favorites  =  [\n                     colors  =  [\n                         blue ,\n                         green \n                    ],\n                     foods  =  [\n                         pho ,\n                         fajitas \n                    ]\n                ]\n            ],\n            [\n                 name  =   Logan ,\n                 favorites  =  [\n                     colors  =  [\n                         red \n                    ],\n                     foods  =  [\n                         hamburgers ,\n                         curry \n                    ]\n                ]\n            ]\n        ]\n    ]\n]  Let's do some things with this data set using lenses.", 
            "title": "Advanced Example"
        }, 
        {
            "location": "/advanced/lenses/#can-you-paint-with-all-the-colors-of-the-api", 
            "text": "By combining several  ArrayList  functions and  viewL , we can gather up all the colors in our data set.  // The Lens::pathLens() function let's us shortcut explicitly composing lenses by doing it for us.\n// We just supply an array of index strings.\n$colorsLens = Lens::pathLens(['favorites', 'colors']);\n\n$colors = ArrayList::flatten(\n    ArrayList::map(Lens::viewL($colorsLens), $someApiResponse['data']['users'])\n);", 
            "title": "Can you paint with all the colors of the API?"
        }, 
        {
            "location": "/advanced/lenses/#everybody-likes-tacos", 
            "text": "Let's use the  overL  function to append \"tacos\" to everyone's favorite foods.  $usersLens = Lens::pathLens(['data', 'users']);\n$foodsLens = Lens::pathLens(['favorites', 'foods']);\n\n$withTacos = Lens::overL(\n    $usersLens,\n    ArrayList::map(\n        Lens::overL($foodLens, ArrayList::cons('tacos'))\n    ),\n    $someApiResponse\n);", 
            "title": "Everybody likes tacos"
        }, 
        {
            "location": "/advanced/lenses/#tag-youre-it", 
            "text": "Let's say we want to tag a timestamp field of our response in the  meta  block. We're going to use a special type of lens here\ncalled a  safe  lens. This is a lens that can point to properties that technically don't have to exist. You can see the details\nfor this lens in the Lens API Documentation.  // We're point to meta.timestamp here, which doesn't exist! But that's okay,\n// because we're using a safe lens.\n$timestampLens = Lens::pathLensSafe(['meta', 'timestamp']);\n\n$withTimestamps = Lens::setL(\n    $timestampLens,\n    time(),\n    $someApiResponse\n);", 
            "title": "Tag, you're it"
        }, 
        {
            "location": "/advanced/fam/", 
            "text": "", 
            "title": "Functors, Applicatives & Monads"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/", 
            "text": "bifurcate\nSource\n\n\nArray Bifurcation\n :: (a -\n Bool) -\n [a] -\n ([a], [a])\n\n\nGiven an array and some filtering test that returns a boolean, return two arrays - one array\nof elements that pass the test, and another array of elements that don't. Similar to filter,\nbut returns the elements that fail as well.\n\n\nArrayList::bifurcate($isEven, [1, 2, 3, 4, 5]); // [[2, 4], [1, 3, 5]]\n\n\n\n\n\n\nconcat\nSource\n\n\nArray Concatenation\n :: [a] -\n [a] -\n [a]\n\n\nJoins two arrays together, with the second argument being appended\nto the end of the first. Defers to php build-in function \narray_merge\n,\nso repeated keys will be overwritten.\n\n\nArrayList::concat([1, 2], [2, 3]); // [1, 2, 2, 3]\nArrayList::concat(['a' =\n 1, 'b' =\n 2], ['a' =\n 'foo', 'c' =\n 3]); // ['a' =\n 'foo', 'b' =\n 2, 'c' =\n 3]\n\n\n\n\n\n\ncons\nSource\n\n\nCons Operator\n :: a -\n [a] -\n [a]\n\n\nGiven a value and an array, append that value to the end of the array.\n\n\nArrayList::cons(3, [1, 2]); // [1, 2, 3]\nArrayList::cons(1, []); // [1]\n\n\n\n\n\n\ncontains\nSource\n\n\nArray Contains Element\n :: a -\n [a] -\n Bool\n\n\nReturns true if a given array contains the item to test, or false if\nit does not.\n\n\nArrayList::contains(1, [1, 2, 3]); // true\nArrayList::contains('a', ['b', 'c', 'd']); // false\n\n\n\n\n\n\ndrop\nSource\n\n\nDrop Elements\n :: Int -\n [a] -\n [a]\n\n\nGiven some number n, drop n elements from an input array and return the rest of\nthe elements. If n is greater than the length of the array, returns an empty array.\n\n\nArrayList::drop(2, [1, 2, 3, 4]); // [3, 4]\nArrayList::drop(4, [1, 2]); // []\n\n\n\n\n\n\ndropWhile\nSource\n\n\nDrop Elements with Predicate\n :: (a -\n Bool) -\n [a] -\n [a]\n\n\nGiven some function that returns true or false, drop elements from an array starting\nat the front, testing each element along the way, until that function returns false.\nReturn the array without all of those elements.\n\n\n$greaterThanOne = function($n) { return $n \n 1; };\nArrayList::dropWhile($greaterThanOne, [2, 4, 6, 1, 2, 3]); // [1, 2, 3]\n\n\n\n\n\n\nfilter\nSource\n\n\nFilter a List\n :: (a -\n Bool) -\n [a] -\n [a]\n\n\nReturns a filtered list. Given a function that takes an element and returns\neither true or false, return a list of all the elements\nof the input list that pass the test.\n\n\nArrayList::filter(function($a) { return $a \n 2; }, [1, 2, 3, 4, 5]); // [3, 4, 5], using an inline function\nArrayList::filter(function($a) { return $a \n 2; }, ['foo' =\n 1, 'bar' =\n 3]); // ['foo' =\n 1]\nArrayList::filter(Math::lte(2), [1, 2, 3, 4, 5]); // [1, 2], using `lte` from the Math module\n\n\n\n\n\n\nflatten\nSource\n\n\nArray Flatten\n :: [a] -\n [b]\n\n\nFlattens a nested array structure into a single-dimensional array. Can handle\narrays of arbitrary dimension.\n\n\nArrayList::flatten([1, [2], [[[3, 4, [5]]]]]); // [1, 2, 3, 4, 5]\n\n\n\n\n\n\nfoldl\nSource\n\n\nList Fold - From Left\n :: (b -\n a -\n b) -\n b -\n [a] -\n b\n\n\nFold a list by iterating over the list from left to right. Pass each element, one by one, into\nthe fold function $f, and carry its value over to the next iteration. Also referred to as array\nreduce.\n\n\n$add = function($a, $b) { return $a + $b; };\nArrayList::foldl(Math::add(), 0, [1, 2, 3]); // 6\nArrayList::foldl(Logic::and(), True, [True, True]); // True\nArrayList::foldl(Logic::and(), True, [True, True, False]); // False\n\n\n\n\n\n\ngroupBy\nSource\n\n\nGroup By\n :: (a -\n String) -\n [a] -\n [[a]]\n\n\nGiven a function that turns an element into a string, map over a list of elements\nand return a multi-dimensional array with elements grouped together by their key\ngenerator.\n\n\n$testCase = [1, 2, 3, 4, 5, 6, 7];\n$keyGen = function($a) {\n    return ($a \n= 3) ? 'small' : 'big';\n};\nArrayList::groupBy($keyGen, $testCase); // ['small' =\n [1, 2, 3], 'big' =\n [4, 5, 6, 7]]\n\n\n\n\n\n\nhead\nSource\n\n\nList Head\n :: [a] -\n a\n\n\nReturns the first element of a list, the element at index 0. Also functions\nproperly for key/value arrays, e.g. arrays whose first element may not necessarily\nbe index 0. If an empty array is given, head throws an Exception.\n\n\nArrayList::head([1, 2, 3]); // 1\nArrayList::head(['a' =\n 1, 'b' =\n 2]); // 1\nArrayList::head([]); // Exception thrown\n\n\n\n\n\n\nindex\nSource\n\n\nList Index\n :: Int -\n [a] -\n a\n\n\nReturns the element of a list at the given index. Throws an exception\nif the given index does not exist in the list.\n\n\nArrayList::index(0, [1, 2, 3]); // 1\nArrayList::index('foo', ['bar' =\n 1, 'foo' =\n 2]); // 2\nArrayList::index('baz', [1, 2, 3]); // Exception thrown\n\n\n\n\n\n\ninit\nSource\n\n\nInitial List Values\n :: [a] -\n [a]\n\n\nReturns an array without its last element, e.g. the inverse of \ntail\n. Works on\nkey/value arrays as well as 'regular' arrays. If an empty or single-value array is given,\nreturns an empty array.\n\n\nArrayList::init([1, 2, 3]); // [1, 2]\nArrayList::init(['a' =\n 1, 'b' =\n 2]); // ['a' =\n 1];\n\n\n\n\n\n\nkeys\nSource\n\n\nArray Keys\n :: [a] -\n [b]\n\n\nReturns the keys of an associative key/value array. Returns numerical indexes\nfor non key/value arrays.\n\n\nArrayList::keys(['a' =\n 1, 'b' =\n 2]); // ['a', 'b']\nArrayList::keys([1, 2, 3]); // [0, 1, 2]\n\n\n\n\n\n\nlast\nSource\n\n\nLast List Value\n :: [a] -\n a\n\n\nReturns the last element of an array, e.g. the complement of \ninit\n. Works on key/value\narrays as well as 'regular' arrays. If an empty array is given, throws an exception.\n\n\nArrayList::last([1, 2, 3]); // 3\nArrayList::last(['a' =\n 1, 'b' =\n 2]); // 2\nArrayList::last([]); // Exception thrown\n\n\n\n\n\n\nlength\nSource\n\n\nArray Length\n :: [a] -\n a\n\n\nReturns the length of a list or array. Wraps php \ncount\n function.\n\n\nArrayList::length([1, 2, 3]); // 3\nArrayList::length(['a' =\n 1, 'b' =\n 2]); // 2\n\n\n\n\n\n\nmap\nSource\n\n\nArray Map\n :: (a -\n b) -\n [a] -\n [b]\n\n\nGiven some function and a list of arbitrary length, return a new array that is the\nresult of calling the given function on each element of the original list.\n\n\nArrayList::map($add(1), [1, 2, 3]); // [2, 3, 4]\n\n\n\n\n\n\nmapIndexed\nSource\n\n\nArray Map Indexed\n :: (a -\n b -\n c) -\n [a] -\n [c]\n\n\nGiven some function and a list of arbitrary length, return a new array that is the\nresult of calling the given function on each element of the original list. The first argument\nof the mapping function is the value, and the second argument is the key or index of the array being\nmapped over.\n\n\nArrayList::mapIndexed($filterEvenIndexes, [1, 2, 3]); // [null, 2, null]\n\n\n\n\n\n\nreplicate\nSource\n\n\nReplicate Item\n :: Int -\n a -\n [a]\n\n\nGiven some integer n and an item to repeat, repeat that item and place\nthe results into an array of length n.\n\n\nArrayList::replicate(5, 'foo'); // ['foo', 'foo', 'foo', 'foo', 'foo']\n\n\n\n\n\n\nreverse\nSource\n\n\nArray Reverse\n :: [a] -\n [a]\n\n\nFlip the order of a given array. Does not modify the original array.\n\n\nArrayList::reverse([1, 2, 3]); // [3, 2, 1]\n\n\n\n\n\n\nsetIndex\nSource\n\n\nSet Array Value\n :: a -\n b -\n [b] -\n [b]\n\n\nSets the value of an array at the given index; works for non-numerical indexes.\nThe value is set in an immutable way, so the original array is not modified.\n\n\nArrayList::setValue(0, 'foo', [1, 2, 3]); // ['foo', 2, 3]\nArrayList::setValue('c', 3, ['a' =\n 1, 'b' =\n 2]); // ['a' =\n 1, 'b' =\n 2, 'c' =\n 3]\n\n\n\n\n\n\nsort\nSource\n\n\nArray Sort\n :: (a -\n a -\n Int) -\n [a] -\n [a]\n\n\nGiven a function that compares two values, sort an array. This function defers to usort\nbut does not mutate the original array. The comparison function should return -1 if the\nfirst argument is ordered before the second, 0 if it's the same ordering, and 1 if\nfirst argument is ordered after the second.\n\n\n$comp = function($a, $b) { return $a \n=\n $b; };\nArrayList::sort($comp, [3, 2, 1]);\n\n\n\n\n\n\ntail\nSource\n\n\nList Tail\n :: [a] -\n [a]\n\n\nReturns an array without its first element, e.g. the complement of \nhead\n. Works on\nkey/value arrays as well as 'regular' arrays. If an empty array of an array of one element\nis given, returns an empty array.\n\n\nArrayList::([1, 2, 3]); // [2, 3]\nArrayList::(['a' =\n 1, 'b' =\n 2]); // ['b' =\n 2];\n\n\n\n\n\n\ntake\nSource\n\n\nTake Elements\n :: Int -\n [a] -\n [a]\n\n\nGiven some number n, return the first n elements of a given array. Returns the whole\narray if n is greater than the array length.\n\n\nArrayList::take(3, [1, 2, 3, 4, 5]); // [1, 2, 3]\n\n\n\n\n\n\ntakeLast\nSource\n\n\ntakeLast\n :: Int -\n [a] -\n [a]\n\n\nReturn the last n items from a list\n\n\nArrayList::takeLast(2, [1, 2, 2, 4]); // [2, 4]\n\n\n\n\n\n\ntakeWhile\nSource\n\n\nTake Elements with Predicate\n :: (a -\n Bool) -\n [a] -\n [a]\n\n\nGiven some function that returns true or false, return the first elements of the array\nthat all pass the test, until the test fails.\n\n\n$greaterThanOne = function($n) { return $n \n 1; };\nArrayList::takeWhile($greaterThanOne, [5, 5, 5, 1, 5, 5]); // [5, 5, 5]\n\n\n\n\n\n\nunique\nSource\n\n\nUnique\n :: [a] -\n [a]\n\n\nGiven a list, return only unique values\n\n\nArrayList::unique([1, 2, 2, 4]); // [1, 2, 4]\n\n\n\n\n\n\nvalues\nSource\n\n\nArray Values\n :: [a] -\n [a]\n\n\nReturns the values of an associative key/value array.\n\n\nArrayList::values(['a' =\n 1, 'b' =\n 2]); // [1, 2]\nArrayList::values([1, 2, 3]); // [1, 2, 3]\n\n\n\n\n\n\nzip\nSource\n\n\nArray Zip\n :: [a] -\n [b] -\n [(a, b)]\n\n\nGiven two arrays a and b, return a new array where each element is a tuple of a and b. If a and b\nare not the same length, the resultant array will always be the same length as the shorter array.\n\n\nArrayList::zip([1, 2, 3], ['a', 'b', 'c']); // [[1, 'a'], [2, 'b'], [3, 'c']]\n\n\n\n\n\n\nzipWith\nSource\n\n\nCustom Array Zip\n :: (a -\n b -\n c) -\n [a] -\n [b] -\n [c]\n\n\nGiven two arrays a and b, and some combinator f, combine the arrays using the combinator\nf(ai, bi) into a new array c. If a and b are not the same length, the resultant array will\nalways be the same length as the shorter array, i.e. the zip stops when it runs out of pairs.\n\n\n$combinator = function($a, $b) { return $a + $b; };\nArrayList::zipWith($combinator, [1, 2, 3], [0, 8, -1]); // [1, 10, 2]\n$combinator = function($a, $b) { return $a - $b; };\nArrayList::zipWith($combinator, [0], [1, 2, 3]); // [-1]", 
            "title": "ArrayList"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#bifurcatesource", 
            "text": "Array Bifurcation  :: (a -  Bool) -  [a] -  ([a], [a])  Given an array and some filtering test that returns a boolean, return two arrays - one array\nof elements that pass the test, and another array of elements that don't. Similar to filter,\nbut returns the elements that fail as well.  ArrayList::bifurcate($isEven, [1, 2, 3, 4, 5]); // [[2, 4], [1, 3, 5]]", 
            "title": "bifurcateSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#concatsource", 
            "text": "Array Concatenation  :: [a] -  [a] -  [a]  Joins two arrays together, with the second argument being appended\nto the end of the first. Defers to php build-in function  array_merge ,\nso repeated keys will be overwritten.  ArrayList::concat([1, 2], [2, 3]); // [1, 2, 2, 3]\nArrayList::concat(['a' =  1, 'b' =  2], ['a' =  'foo', 'c' =  3]); // ['a' =  'foo', 'b' =  2, 'c' =  3]", 
            "title": "concatSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#conssource", 
            "text": "Cons Operator  :: a -  [a] -  [a]  Given a value and an array, append that value to the end of the array.  ArrayList::cons(3, [1, 2]); // [1, 2, 3]\nArrayList::cons(1, []); // [1]", 
            "title": "consSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#containssource", 
            "text": "Array Contains Element  :: a -  [a] -  Bool  Returns true if a given array contains the item to test, or false if\nit does not.  ArrayList::contains(1, [1, 2, 3]); // true\nArrayList::contains('a', ['b', 'c', 'd']); // false", 
            "title": "containsSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#dropsource", 
            "text": "Drop Elements  :: Int -  [a] -  [a]  Given some number n, drop n elements from an input array and return the rest of\nthe elements. If n is greater than the length of the array, returns an empty array.  ArrayList::drop(2, [1, 2, 3, 4]); // [3, 4]\nArrayList::drop(4, [1, 2]); // []", 
            "title": "dropSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#dropwhilesource", 
            "text": "Drop Elements with Predicate  :: (a -  Bool) -  [a] -  [a]  Given some function that returns true or false, drop elements from an array starting\nat the front, testing each element along the way, until that function returns false.\nReturn the array without all of those elements.  $greaterThanOne = function($n) { return $n   1; };\nArrayList::dropWhile($greaterThanOne, [2, 4, 6, 1, 2, 3]); // [1, 2, 3]", 
            "title": "dropWhileSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#filtersource", 
            "text": "Filter a List  :: (a -  Bool) -  [a] -  [a]  Returns a filtered list. Given a function that takes an element and returns\neither true or false, return a list of all the elements\nof the input list that pass the test.  ArrayList::filter(function($a) { return $a   2; }, [1, 2, 3, 4, 5]); // [3, 4, 5], using an inline function\nArrayList::filter(function($a) { return $a   2; }, ['foo' =  1, 'bar' =  3]); // ['foo' =  1]\nArrayList::filter(Math::lte(2), [1, 2, 3, 4, 5]); // [1, 2], using `lte` from the Math module", 
            "title": "filterSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#flattensource", 
            "text": "Array Flatten  :: [a] -  [b]  Flattens a nested array structure into a single-dimensional array. Can handle\narrays of arbitrary dimension.  ArrayList::flatten([1, [2], [[[3, 4, [5]]]]]); // [1, 2, 3, 4, 5]", 
            "title": "flattenSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#foldlsource", 
            "text": "List Fold - From Left  :: (b -  a -  b) -  b -  [a] -  b  Fold a list by iterating over the list from left to right. Pass each element, one by one, into\nthe fold function $f, and carry its value over to the next iteration. Also referred to as array\nreduce.  $add = function($a, $b) { return $a + $b; };\nArrayList::foldl(Math::add(), 0, [1, 2, 3]); // 6\nArrayList::foldl(Logic::and(), True, [True, True]); // True\nArrayList::foldl(Logic::and(), True, [True, True, False]); // False", 
            "title": "foldlSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#groupbysource", 
            "text": "Group By  :: (a -  String) -  [a] -  [[a]]  Given a function that turns an element into a string, map over a list of elements\nand return a multi-dimensional array with elements grouped together by their key\ngenerator.  $testCase = [1, 2, 3, 4, 5, 6, 7];\n$keyGen = function($a) {\n    return ($a  = 3) ? 'small' : 'big';\n};\nArrayList::groupBy($keyGen, $testCase); // ['small' =  [1, 2, 3], 'big' =  [4, 5, 6, 7]]", 
            "title": "groupBySource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#headsource", 
            "text": "List Head  :: [a] -  a  Returns the first element of a list, the element at index 0. Also functions\nproperly for key/value arrays, e.g. arrays whose first element may not necessarily\nbe index 0. If an empty array is given, head throws an Exception.  ArrayList::head([1, 2, 3]); // 1\nArrayList::head(['a' =  1, 'b' =  2]); // 1\nArrayList::head([]); // Exception thrown", 
            "title": "headSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#indexsource", 
            "text": "List Index  :: Int -  [a] -  a  Returns the element of a list at the given index. Throws an exception\nif the given index does not exist in the list.  ArrayList::index(0, [1, 2, 3]); // 1\nArrayList::index('foo', ['bar' =  1, 'foo' =  2]); // 2\nArrayList::index('baz', [1, 2, 3]); // Exception thrown", 
            "title": "indexSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#initsource", 
            "text": "Initial List Values  :: [a] -  [a]  Returns an array without its last element, e.g. the inverse of  tail . Works on\nkey/value arrays as well as 'regular' arrays. If an empty or single-value array is given,\nreturns an empty array.  ArrayList::init([1, 2, 3]); // [1, 2]\nArrayList::init(['a' =  1, 'b' =  2]); // ['a' =  1];", 
            "title": "initSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#keyssource", 
            "text": "Array Keys  :: [a] -  [b]  Returns the keys of an associative key/value array. Returns numerical indexes\nfor non key/value arrays.  ArrayList::keys(['a' =  1, 'b' =  2]); // ['a', 'b']\nArrayList::keys([1, 2, 3]); // [0, 1, 2]", 
            "title": "keysSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#lastsource", 
            "text": "Last List Value  :: [a] -  a  Returns the last element of an array, e.g. the complement of  init . Works on key/value\narrays as well as 'regular' arrays. If an empty array is given, throws an exception.  ArrayList::last([1, 2, 3]); // 3\nArrayList::last(['a' =  1, 'b' =  2]); // 2\nArrayList::last([]); // Exception thrown", 
            "title": "lastSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#lengthsource", 
            "text": "Array Length  :: [a] -  a  Returns the length of a list or array. Wraps php  count  function.  ArrayList::length([1, 2, 3]); // 3\nArrayList::length(['a' =  1, 'b' =  2]); // 2", 
            "title": "lengthSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#mapsource", 
            "text": "Array Map  :: (a -  b) -  [a] -  [b]  Given some function and a list of arbitrary length, return a new array that is the\nresult of calling the given function on each element of the original list.  ArrayList::map($add(1), [1, 2, 3]); // [2, 3, 4]", 
            "title": "mapSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#mapindexedsource", 
            "text": "Array Map Indexed  :: (a -  b -  c) -  [a] -  [c]  Given some function and a list of arbitrary length, return a new array that is the\nresult of calling the given function on each element of the original list. The first argument\nof the mapping function is the value, and the second argument is the key or index of the array being\nmapped over.  ArrayList::mapIndexed($filterEvenIndexes, [1, 2, 3]); // [null, 2, null]", 
            "title": "mapIndexedSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#replicatesource", 
            "text": "Replicate Item  :: Int -  a -  [a]  Given some integer n and an item to repeat, repeat that item and place\nthe results into an array of length n.  ArrayList::replicate(5, 'foo'); // ['foo', 'foo', 'foo', 'foo', 'foo']", 
            "title": "replicateSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#reversesource", 
            "text": "Array Reverse  :: [a] -  [a]  Flip the order of a given array. Does not modify the original array.  ArrayList::reverse([1, 2, 3]); // [3, 2, 1]", 
            "title": "reverseSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#setindexsource", 
            "text": "Set Array Value  :: a -  b -  [b] -  [b]  Sets the value of an array at the given index; works for non-numerical indexes.\nThe value is set in an immutable way, so the original array is not modified.  ArrayList::setValue(0, 'foo', [1, 2, 3]); // ['foo', 2, 3]\nArrayList::setValue('c', 3, ['a' =  1, 'b' =  2]); // ['a' =  1, 'b' =  2, 'c' =  3]", 
            "title": "setIndexSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#sortsource", 
            "text": "Array Sort  :: (a -  a -  Int) -  [a] -  [a]  Given a function that compares two values, sort an array. This function defers to usort\nbut does not mutate the original array. The comparison function should return -1 if the\nfirst argument is ordered before the second, 0 if it's the same ordering, and 1 if\nfirst argument is ordered after the second.  $comp = function($a, $b) { return $a  =  $b; };\nArrayList::sort($comp, [3, 2, 1]);", 
            "title": "sortSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#tailsource", 
            "text": "List Tail  :: [a] -  [a]  Returns an array without its first element, e.g. the complement of  head . Works on\nkey/value arrays as well as 'regular' arrays. If an empty array of an array of one element\nis given, returns an empty array.  ArrayList::([1, 2, 3]); // [2, 3]\nArrayList::(['a' =  1, 'b' =  2]); // ['b' =  2];", 
            "title": "tailSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#takesource", 
            "text": "Take Elements  :: Int -  [a] -  [a]  Given some number n, return the first n elements of a given array. Returns the whole\narray if n is greater than the array length.  ArrayList::take(3, [1, 2, 3, 4, 5]); // [1, 2, 3]", 
            "title": "takeSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#takelastsource", 
            "text": "takeLast  :: Int -  [a] -  [a]  Return the last n items from a list  ArrayList::takeLast(2, [1, 2, 2, 4]); // [2, 4]", 
            "title": "takeLastSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#takewhilesource", 
            "text": "Take Elements with Predicate  :: (a -  Bool) -  [a] -  [a]  Given some function that returns true or false, return the first elements of the array\nthat all pass the test, until the test fails.  $greaterThanOne = function($n) { return $n   1; };\nArrayList::takeWhile($greaterThanOne, [5, 5, 5, 1, 5, 5]); // [5, 5, 5]", 
            "title": "takeWhileSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#uniquesource", 
            "text": "Unique  :: [a] -  [a]  Given a list, return only unique values  ArrayList::unique([1, 2, 2, 4]); // [1, 2, 4]", 
            "title": "uniqueSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#valuessource", 
            "text": "Array Values  :: [a] -  [a]  Returns the values of an associative key/value array.  ArrayList::values(['a' =  1, 'b' =  2]); // [1, 2]\nArrayList::values([1, 2, 3]); // [1, 2, 3]", 
            "title": "valuesSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#zipsource", 
            "text": "Array Zip  :: [a] -  [b] -  [(a, b)]  Given two arrays a and b, return a new array where each element is a tuple of a and b. If a and b\nare not the same length, the resultant array will always be the same length as the shorter array.  ArrayList::zip([1, 2, 3], ['a', 'b', 'c']); // [[1, 'a'], [2, 'b'], [3, 'c']]", 
            "title": "zipSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/ArrayList/#zipwithsource", 
            "text": "Custom Array Zip  :: (a -  b -  c) -  [a] -  [b] -  [c]  Given two arrays a and b, and some combinator f, combine the arrays using the combinator\nf(ai, bi) into a new array c. If a and b are not the same length, the resultant array will\nalways be the same length as the shorter array, i.e. the zip stops when it runs out of pairs.  $combinator = function($a, $b) { return $a + $b; };\nArrayList::zipWith($combinator, [1, 2, 3], [0, 8, -1]); // [1, 10, 2]\n$combinator = function($a, $b) { return $a - $b; };\nArrayList::zipWith($combinator, [0], [1, 2, 3]); // [-1]", 
            "title": "zipWithSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Lambda/", 
            "text": "compose\n\n\nThis function is currently missing documentation.\n\n\n\n\nflip\nSource\n\n\nFlip Combinator\n :: (a -\n b -\n c) -\n b -\n a -\n c\n\n\nGiven a function that takes two arguments, return a new function that\ntakes those two arguments with their order reversed.\n\n\nMath::subtract(2, 6); // 4\nLambda::flip(Math::subtract())(2, 6); // -4\n\n\n\n\n\n\nid\nSource\n\n\nIdentity Function\n :: a -\n a\n\n\nGiven some value a, return a unchanged\n\n\nLambda::id(4); // 4\nLambda::id('foo'); // 'foo'\n\n\n\n\n\n\nk\nSource\n\n\nK Combinator\n :: a -\n (b -\n a)\n\n\nGiven some value k, return a lambda expression which always evaluates to k, regardless\nof any arguments it is given.\n\n\n$alwaysFour = Lambda::k(4);\n$alwaysFour('foo'); // 4\n$alwaysFour(1, 2, 3); // 4\n$alwaysFour(); // 4\n\n\n\n\n\n\npipe\n\n\nThis function is currently missing documentation.", 
            "title": "Lambda"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Lambda/#compose", 
            "text": "This function is currently missing documentation.", 
            "title": "compose"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Lambda/#flipsource", 
            "text": "Flip Combinator  :: (a -  b -  c) -  b -  a -  c  Given a function that takes two arguments, return a new function that\ntakes those two arguments with their order reversed.  Math::subtract(2, 6); // 4\nLambda::flip(Math::subtract())(2, 6); // -4", 
            "title": "flipSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Lambda/#idsource", 
            "text": "Identity Function  :: a -  a  Given some value a, return a unchanged  Lambda::id(4); // 4\nLambda::id('foo'); // 'foo'", 
            "title": "idSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Lambda/#ksource", 
            "text": "K Combinator  :: a -  (b -  a)  Given some value k, return a lambda expression which always evaluates to k, regardless\nof any arguments it is given.  $alwaysFour = Lambda::k(4);\n$alwaysFour('foo'); // 4\n$alwaysFour(1, 2, 3); // 4\n$alwaysFour(); // 4", 
            "title": "kSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Lambda/#pipe", 
            "text": "This function is currently missing documentation.", 
            "title": "pipe"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/", 
            "text": "all\nSource\n\n\nAll\n :: array -\n Bool\n\n\nReturns true given all values are truthy\n\n\nLogic::all(1, 'asdf', true); // True\nLogic::all(1, false); // False\n\n\n\n\n\n\nandCombinator\nSource\n\n\nLogical And Combinator\n :: [(a -\n Bool)] -\n a -\n Bool\n\n\nGiven n functions {f1, f2, ..., fn}, combine them in such a way to produce a new\nfunction g that returns true given {f1(x), f2(x), ... fn(x)} all return true.\n\n\n$funcF = function($x) { return $x \n 5; };\n$funcG = function($x) { return $x \n 0; };\n$combinator = Logic::andCombinator([$funcF, $funcG]);\n$combinator(4); // True\n$combinator(2); // True\n$combinator(7); // False\n\n\n\n\n\n\nany\nSource\n\n\nAny\n :: array -\n Bool\n\n\nReturns true given any values are truthy\n\n\nLogic::any(true, false); // True\nLogic::any(false, false); // False\n\n\n\n\n\n\neq\nSource\n\n\nEqual (Not Strict / ==)\n :: mixed -\n mixed -\n Bool\n\n\nReturns true given $a equals $b\n\n\nLogic::eq(1, 1); // True\nLogic::eq(1, 2); // False\n\n\n\n\n\n\neqStrict\nSource\n\n\nEqual (Strict / ===)\n :: mixed -\n mixed -\n Bool\n\n\nReturns true given $a equals $b\n\n\nLogic::eqStrict(1, 1); // True\nLogic::eqStrict(1, '1'); // False\n\n\n\n\n\n\ngt\nSource\n\n\nGreater Than\n :: mixed -\n mixed -\n Bool\n\n\nReturns true given $b is greater than $a.\n\n\nLogic::gt(2, 1); // False\nLogic::gt(1, 2); // True\n\n\n\n\n\n\ngte\nSource\n\n\nGreater Than Or Equal\n :: mixed -\n mixed -\n Bool\n\n\nReturns true given $b is greater than or equal to $a.\n\n\nLogic::gte(1, 1); // True\nLogic::gte(1, 2); // True\n\n\n\n\n\n\nlogicalAnd\nSource\n\n\nLogical And\n :: Bool -\n Bool -\n Bool\n\n\nReturns true given $a AND $b are true.\n\n\nLogic::logicalAnd(true, true); // True\nLogic::logicalAnd(true, false); // False\n\n\n\n\n\n\nlogicalNot\nSource\n\n\nLogical Not\n :: Bool -\n Bool\n\n\nReturns true given $a is false.\nReturns false given $a is true.\n\n\nLogic::logicalNot(true); // False\nLogic::logicalNot(false); // True\n\n\n\n\n\n\nlogicalOr\nSource\n\n\nLogical Or\n :: Bool -\n Bool -\n Bool\n\n\nReturns true given $a OR $b returns true.\n\n\nLogic::logicalOr(true, false); // True\nLogic::logicalOr(false, false); // False\n\n\n\n\n\n\nlt\nSource\n\n\nLess Than\n :: mixed -\n mixed -\n Bool\n\n\nReturns true given $b is less than $a.\n\n\nLogic::lt(2, 1); // True\nLogic::lt(1, 2); // False\n\n\n\n\n\n\nlte\nSource\n\n\nLess Than Or Equal\n :: mixed -\n mixed -\n Bool\n\n\nReturns true given $b is less than or equal to $a.\n\n\nLogic::lte(1, 1); // True\nLogic::lte(2, 1); // True\n\n\n\n\n\n\nnotEq\nSource\n\n\nNot Equal (Not Strict / ==)\n :: mixed -\n mixed -\n Bool\n\n\nReturns true given $a does not equal $b\n\n\nLogic::notEq(1, 1); // False\nLogic::notEq(1, 2); // True\n\n\n\n\n\n\nnotEqStrict\nSource\n\n\nNot Equal (Strict / ===)\n :: mixed -\n mixed -\n Bool\n\n\nReturns true given $a does not equal $b\n\n\nLogic::notEqStrict(1, 2); // True\nLogic::notEqStrict(1, '1'); // False\n\n\n\n\n\n\norCombinator\nSource\n\n\nLogical Or Combinator\n :: [(a -\n Bool)] -\n a -\n Bool\n\n\nGiven n functions {f1, f2, ..., fn}, combine them in such a way to produce a new\nfunction g that returns true given at least one of {f1(x), f2(x), ... fn(x)} return true.\n\n\n$funcF = function($x) { return $x \n= 5; };\n$funcG = function($x) { return $x == 0; };\n$combinator = Logic::orCombinator([$funcF, $funcG]);\n$combinator(9); // True\n$combinator(0); // True\n$combinator(2); // False", 
            "title": "Logic"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#allsource", 
            "text": "All  :: array -  Bool  Returns true given all values are truthy  Logic::all(1, 'asdf', true); // True\nLogic::all(1, false); // False", 
            "title": "allSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#andcombinatorsource", 
            "text": "Logical And Combinator  :: [(a -  Bool)] -  a -  Bool  Given n functions {f1, f2, ..., fn}, combine them in such a way to produce a new\nfunction g that returns true given {f1(x), f2(x), ... fn(x)} all return true.  $funcF = function($x) { return $x   5; };\n$funcG = function($x) { return $x   0; };\n$combinator = Logic::andCombinator([$funcF, $funcG]);\n$combinator(4); // True\n$combinator(2); // True\n$combinator(7); // False", 
            "title": "andCombinatorSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#anysource", 
            "text": "Any  :: array -  Bool  Returns true given any values are truthy  Logic::any(true, false); // True\nLogic::any(false, false); // False", 
            "title": "anySource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#eqsource", 
            "text": "Equal (Not Strict / ==)  :: mixed -  mixed -  Bool  Returns true given $a equals $b  Logic::eq(1, 1); // True\nLogic::eq(1, 2); // False", 
            "title": "eqSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#eqstrictsource", 
            "text": "Equal (Strict / ===)  :: mixed -  mixed -  Bool  Returns true given $a equals $b  Logic::eqStrict(1, 1); // True\nLogic::eqStrict(1, '1'); // False", 
            "title": "eqStrictSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#gtsource", 
            "text": "Greater Than  :: mixed -  mixed -  Bool  Returns true given $b is greater than $a.  Logic::gt(2, 1); // False\nLogic::gt(1, 2); // True", 
            "title": "gtSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#gtesource", 
            "text": "Greater Than Or Equal  :: mixed -  mixed -  Bool  Returns true given $b is greater than or equal to $a.  Logic::gte(1, 1); // True\nLogic::gte(1, 2); // True", 
            "title": "gteSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#logicalandsource", 
            "text": "Logical And  :: Bool -  Bool -  Bool  Returns true given $a AND $b are true.  Logic::logicalAnd(true, true); // True\nLogic::logicalAnd(true, false); // False", 
            "title": "logicalAndSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#logicalnotsource", 
            "text": "Logical Not  :: Bool -  Bool  Returns true given $a is false.\nReturns false given $a is true.  Logic::logicalNot(true); // False\nLogic::logicalNot(false); // True", 
            "title": "logicalNotSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#logicalorsource", 
            "text": "Logical Or  :: Bool -  Bool -  Bool  Returns true given $a OR $b returns true.  Logic::logicalOr(true, false); // True\nLogic::logicalOr(false, false); // False", 
            "title": "logicalOrSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#ltsource", 
            "text": "Less Than  :: mixed -  mixed -  Bool  Returns true given $b is less than $a.  Logic::lt(2, 1); // True\nLogic::lt(1, 2); // False", 
            "title": "ltSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#ltesource", 
            "text": "Less Than Or Equal  :: mixed -  mixed -  Bool  Returns true given $b is less than or equal to $a.  Logic::lte(1, 1); // True\nLogic::lte(2, 1); // True", 
            "title": "lteSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#noteqsource", 
            "text": "Not Equal (Not Strict / ==)  :: mixed -  mixed -  Bool  Returns true given $a does not equal $b  Logic::notEq(1, 1); // False\nLogic::notEq(1, 2); // True", 
            "title": "notEqSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#noteqstrictsource", 
            "text": "Not Equal (Strict / ===)  :: mixed -  mixed -  Bool  Returns true given $a does not equal $b  Logic::notEqStrict(1, 2); // True\nLogic::notEqStrict(1, '1'); // False", 
            "title": "notEqStrictSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Logic/#orcombinatorsource", 
            "text": "Logical Or Combinator  :: [(a -  Bool)] -  a -  Bool  Given n functions {f1, f2, ..., fn}, combine them in such a way to produce a new\nfunction g that returns true given at least one of {f1(x), f2(x), ... fn(x)} return true.  $funcF = function($x) { return $x  = 5; };\n$funcG = function($x) { return $x == 0; };\n$combinator = Logic::orCombinator([$funcF, $funcG]);\n$combinator(9); // True\n$combinator(0); // True\n$combinator(2); // False", 
            "title": "orCombinatorSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Math/", 
            "text": "add\nSource\n\n\nArithmetic Addition\n :: Number a =\n a -\n a -\n a\n\n\nAdd two numbers together.\n\n\nMath::add(2, 2); // 4\nMath::add(-1, 2); // 1\n\n\n\n\n\n\ndivide\nSource\n\n\nArithmetic Division\n :: Number a =\n a -\n a -\n a\n\n\nDivide two numbers, with the first argument being the divisor.\n\n\nMath::divide(2, 8); // 4\nMath::divide(4, 12); // 3\n\n\n\n\n\n\nmax\nSource\n\n\nMaximum Value\n :: Number a =\n a -\n a -\n a\n\n\nReturns the maximum of two arguments a and b. If a and b are equal, just returns the value.\n\n\nMath::max(1, 2); // 2\nMath::max(-1, -6); // -1\nMath::max(5, 5); // 5\n\n\n\n\n\n\nmean\nSource\n\n\nArithmetic mean\n :: Number a =\n [a] -\n a\n\n\nReturns the average of a list, or zero for an empty list.\n\n\nMath::mean([1, 2, 3]); // (1 + 2 + 3) / 3 = 2\nMath::mean([]); // 0\n\n\n\n\n\n\nmin\nSource\n\n\nMinimum Value\n :: Number a =\n a -\n a -\n a\n\n\nReturns the minimum of two arguments a and b.\nIf a and be are equal, returns the first value. But since they're equal, that doesn't\nreally matter now does it?\n\n\nMath::min(1, 2); // 1\nMath::min(-1, -6); // -6\nMath::min(5, 5); // 5\n\n\n\n\n\n\nmod\nSource\n\n\nModulus Operator\n :: Int -\n Int -\n Int\n\n\nTake the modulus of two integers, with the first argument being the divisor.\nReturns the remainder of $b / $a.\n\n\nMath::mod(2, 5); // 1\nMath::mod(5, 12); // 2\nMath::mod(3, 3); // 0\n\n\n\n\n\n\nmultiply\nSource\n\n\nArithmetic Multiplication\n :: Number a =\n a -\n a -\n a\n\n\nMultiply two numbers together.\n\n\nMath::multiply(2, 4); // 8\nMath::multiply(0, 4); // 0\n\n\n\n\n\n\nnegate\nSource\n\n\nNegate a number.\n :: Number a =\n a -\n a\n\n\nReturns a given number * -1.\n\n\nMath::negate(4); // -4\nMath::negate(0); // 0\n\n\n\n\n\n\npow\nSource\n\n\nPower function\n :: Number a =\n a -\n a -\n a\n\n\nArithmetic exponentiation. Raises the second argument to the power\nof the first.\n\n\nMath::pow(2, 3); // 3 ^ 2 = 9\nMath::pow(3, 2); // 2 ^ 3 = 8\n\n\n\n\n\n\nproduct\nSource\n\n\nArray Product\n :: Number a =\n [a] -\n a\n\n\nReturns the product of a list of numbers, i.e. the result of multiplying\nevery element of a list together. Returns 1 for an empty list.\n\n\nMath::product([2, 2, 3]); // 12\nMath::product([]); // 1\n\n\n\n\n\n\nrange\nSource\n\n\nNumber Range\n :: Number a =\n a -\n a -\n a\n\n\nGiven two values m and n, return all values between m and n in an array, inclusive, with a\nstep size of $step. The list of numbers will start at the first value and approach the second value.\n\n\nMath::range(1, 1, 5); // [1, 2, 3, 4, 5]\nMath::range(2, 0, -3); // [0, -2]\nMath::range(0, 0, 0); // [0]\nMath::range(0.1, 0, 0.5); // [0, 0.1, 0.2, 0.3, 0.4, 0.5]\n\n\n\n\n\n\nsubtract\nSource\n\n\nArithmetic Subtraction.\n :: Number a =\n a -\n a -\n a\n\n\nSubtracts two numbers, with the first argument being subtracted from the second.\n\n\nMath::subtract(4, 9); // 5\nMath::subtract(-1, 3); // 4\n\n\n\n\n\n\nsum\nSource\n\n\nArray Sum\n :: Number a =\n [a] -\n a\n\n\nAdd all the numbers of a list together and return their sum. If the given\nlist is empty, returns 0.\n\n\nMath::sum([1, 2, 3]); // 6\nMath::sum([]); // 0", 
            "title": "Math"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Math/#addsource", 
            "text": "Arithmetic Addition  :: Number a =  a -  a -  a  Add two numbers together.  Math::add(2, 2); // 4\nMath::add(-1, 2); // 1", 
            "title": "addSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Math/#dividesource", 
            "text": "Arithmetic Division  :: Number a =  a -  a -  a  Divide two numbers, with the first argument being the divisor.  Math::divide(2, 8); // 4\nMath::divide(4, 12); // 3", 
            "title": "divideSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Math/#maxsource", 
            "text": "Maximum Value  :: Number a =  a -  a -  a  Returns the maximum of two arguments a and b. If a and b are equal, just returns the value.  Math::max(1, 2); // 2\nMath::max(-1, -6); // -1\nMath::max(5, 5); // 5", 
            "title": "maxSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Math/#meansource", 
            "text": "Arithmetic mean  :: Number a =  [a] -  a  Returns the average of a list, or zero for an empty list.  Math::mean([1, 2, 3]); // (1 + 2 + 3) / 3 = 2\nMath::mean([]); // 0", 
            "title": "meanSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Math/#minsource", 
            "text": "Minimum Value  :: Number a =  a -  a -  a  Returns the minimum of two arguments a and b.\nIf a and be are equal, returns the first value. But since they're equal, that doesn't\nreally matter now does it?  Math::min(1, 2); // 1\nMath::min(-1, -6); // -6\nMath::min(5, 5); // 5", 
            "title": "minSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Math/#modsource", 
            "text": "Modulus Operator  :: Int -  Int -  Int  Take the modulus of two integers, with the first argument being the divisor.\nReturns the remainder of $b / $a.  Math::mod(2, 5); // 1\nMath::mod(5, 12); // 2\nMath::mod(3, 3); // 0", 
            "title": "modSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Math/#multiplysource", 
            "text": "Arithmetic Multiplication  :: Number a =  a -  a -  a  Multiply two numbers together.  Math::multiply(2, 4); // 8\nMath::multiply(0, 4); // 0", 
            "title": "multiplySource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Math/#negatesource", 
            "text": "Negate a number.  :: Number a =  a -  a  Returns a given number * -1.  Math::negate(4); // -4\nMath::negate(0); // 0", 
            "title": "negateSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Math/#powsource", 
            "text": "Power function  :: Number a =  a -  a -  a  Arithmetic exponentiation. Raises the second argument to the power\nof the first.  Math::pow(2, 3); // 3 ^ 2 = 9\nMath::pow(3, 2); // 2 ^ 3 = 8", 
            "title": "powSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Math/#productsource", 
            "text": "Array Product  :: Number a =  [a] -  a  Returns the product of a list of numbers, i.e. the result of multiplying\nevery element of a list together. Returns 1 for an empty list.  Math::product([2, 2, 3]); // 12\nMath::product([]); // 1", 
            "title": "productSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Math/#rangesource", 
            "text": "Number Range  :: Number a =  a -  a -  a  Given two values m and n, return all values between m and n in an array, inclusive, with a\nstep size of $step. The list of numbers will start at the first value and approach the second value.  Math::range(1, 1, 5); // [1, 2, 3, 4, 5]\nMath::range(2, 0, -3); // [0, -2]\nMath::range(0, 0, 0); // [0]\nMath::range(0.1, 0, 0.5); // [0, 0.1, 0.2, 0.3, 0.4, 0.5]", 
            "title": "rangeSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Math/#subtractsource", 
            "text": "Arithmetic Subtraction.  :: Number a =  a -  a -  a  Subtracts two numbers, with the first argument being subtracted from the second.  Math::subtract(4, 9); // 5\nMath::subtract(-1, 3); // 4", 
            "title": "subtractSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Math/#sumsource", 
            "text": "Array Sum  :: Number a =  [a] -  a  Add all the numbers of a list together and return their sum. If the given\nlist is empty, returns 0.  Math::sum([1, 2, 3]); // 6\nMath::sum([]); // 0", 
            "title": "sumSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Object/", 
            "text": "assign\nSource\n\n\nAssign Properties\n :: array props -\n Object objOriginal -\n Object objUpdated\n\n\nSet/Update properties on the object using a key/value array\n\n\nObject::assign(['value' =\n 'hi!'], new stdClass);\n// object(stdClass)#1 (1) {\n//   [\nvalue\n]=\n\n//   string(3) \nhi!\n\n// }\n\n\n\n\n\n\ngetProp\nSource\n\n\nGet Property\n :: String -\n Object a -\n a\n\n\nGets a property on the object\n\n\n$obj = new stdClass();\n$obj-\nvalue = 'hi!';\nObject::getValue('value', $obj); // 'hi!'\n\n\n\n\n\n\ninvokeMethod\nSource\n\n\nInvoke Method\n :: String -\n Obj a -\n mixed\n\n\nInvokes a method on the object\n\n\n$person = new stdObject(array(\n \nsayHi\n =\n function() {\n     return \nhi!\n;\n }\n));\nObject::invokeMethod('sayHi', $person); // 'hi!'\n\n\n\n\n\n\nisInstanceOf\nSource\n\n\nIs Instance Of\n :: String -\n Obj a -\n mixed\n\n\nChecks if the object is an instance of the specified class\n\n\nObject::isInstanceOf('stdClass', (new stdClass())); // true\n\n\n\n\n\n\nsetProp\nSource\n\n\nSet Property\n :: String -\n a -\n Object a -\n Object a\n\n\nSets a property on the object\n\n\nObject::setValue('value', new stdClass(), 'hi!');\n// object(stdClass)#1 (1) {\n//   [\nvalue\n]=\n\n//   string(3) \nhi!\n\n// }", 
            "title": "Object"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Object/#assignsource", 
            "text": "Assign Properties  :: array props -  Object objOriginal -  Object objUpdated  Set/Update properties on the object using a key/value array  Object::assign(['value' =  'hi!'], new stdClass);\n// object(stdClass)#1 (1) {\n//   [ value ]= \n//   string(3)  hi! \n// }", 
            "title": "assignSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Object/#getpropsource", 
            "text": "Get Property  :: String -  Object a -  a  Gets a property on the object  $obj = new stdClass();\n$obj- value = 'hi!';\nObject::getValue('value', $obj); // 'hi!'", 
            "title": "getPropSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Object/#invokemethodsource", 
            "text": "Invoke Method  :: String -  Obj a -  mixed  Invokes a method on the object  $person = new stdObject(array(\n  sayHi  =  function() {\n     return  hi! ;\n }\n));\nObject::invokeMethod('sayHi', $person); // 'hi!'", 
            "title": "invokeMethodSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Object/#isinstanceofsource", 
            "text": "Is Instance Of  :: String -  Obj a -  mixed  Checks if the object is an instance of the specified class  Object::isInstanceOf('stdClass', (new stdClass())); // true", 
            "title": "isInstanceOfSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Object/#setpropsource", 
            "text": "Set Property  :: String -  a -  Object a -  Object a  Sets a property on the object  Object::setValue('value', new stdClass(), 'hi!');\n// object(stdClass)#1 (1) {\n//   [ value ]= \n//   string(3)  hi! \n// }", 
            "title": "setPropSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Strings/", 
            "text": "chomp\nSource\n\n\nTwo-Sided Chomp\n :: String -\n String\n\n\nRemoves the specified substring from both ends of the target string. Unlike PHP's\ntrim function, the substring to chomp is not a character mask -- rather it is a full\nsubstring. This function is case sensitive.\n\n\nStrings::chomp('a', 'abccba'); // 'bccb'\nStrings::chomp('ab', 'abccba'); // 'abccba'\nStrings::chomp('A', 'abccba'); // 'abccba'\n\n\n\n\n\n\nconcat\nSource\n\n\nString Concatenation\n :: String -\n String -\n String\n\n\nConcatenates the first argument to the second argument, provided both arguments\nare strings. Defers to the PHP built-in concatenation.\n\n\nStrings::concat('as', 'df'); // 'dfas'\nStrings::concat('World', $concat('ello', 'H')); // 'HelloWorld'\n\n\n\n\n\n\njoin\nSource\n\n\nString Joining\n :: String -\n [String] -\n String\n\n\nJoins an array of strings together with a given delimiter. Works similarly\nto PHP \nimplode\n. The inverse of \nsplit\n.\n\n\nStrings::join(' ', ['Hello', 'World']); // 'Hello World'\nStrings::join('', ['a', 's', 'd', 'f']); // 'asdf'\n\n\n\n\n\n\nlchomp\nSource\n\n\nLeft Chomp\n :: String -\n String\n\n\nRemoves the specified substring from the left end of the target string. Unlike PHP's\ntrim function, the substring to chomp is not a character mask -- rather it is a full\nsubstring. This function is case sensitive.\n\n\nStrings::lchomp('He', 'Hello World'); // 'llo World'\nStrings::lchomp('Hi', 'Hello World'); // 'Hello World'\nStrings::lchomp('he', 'Hello World'); // 'Hello World'\n\n\n\n\n\n\nrchomp\nSource\n\n\nRight Chomp\n :: String -\n String\n\n\nRemoves the specified substring from the right end of the target string. Unlike PHP's\ntrim function, the substring to chomp is not a character mask -- rather it is a full\nsubstring. This function is case sensitive.\n\n\nStrings::rchomp('ld', 'Hello World'); // 'Hello Wor'\nStrings::rchomp('li', 'Hello World'); // 'Hello World'\nStrings::rchomp('LD', 'Hello World'); // 'Hello World'\n\n\n\n\n\n\nreplace\nSource\n\n\nString Replace\n :: String -\n String -\n String\n\n\nReplace all occurrences of the search string with the replacement string.\n\n\nStrings::replace('test', 'passes', 'this test']); // 'this passes'\n\n\n\n\n\n\nsplit\nSource\n\n\nString Splitting\n :: String -\n String -\n [String]\n\n\nSplit a string into parts based on a delimiter. Operates similar to php \nexplode\n,\nbut is more consistent. Can split on empty delimiters, and trims out empty strings\nafter exploding.\n\n\nStrings::split('-', 'Hello-World'); // ['Hello', 'World']\nStrings::split('', 'asdf'); // ['a', 's', 'd', 'f']\nStrings::split('-', 'foo-bar-'); ['foo', 'bar']\n\n\n\n\n\n\nstartsWith\nSource\n\n\nSubstring Match\n :: String -\n String -\n Bool\n\n\nDetermines if a string starts with a specific substring. Returns true if the string\nmatches the substring at its start, otherwise false.\n\n\nStrings::startsWith('as', 'asdf'); true\nStrings::startsWith('foo', 'barfoo'); false\n\n\n\n\n\n\ntoLowercase\nSource\n\n\nLowercase Conversion\n :: String -\n String\n\n\nConverts a string to lowercase.\n\n\nStrings::toLowercase('ASdf'); // 'asdf'\n\n\n\n\n\n\ntoUppercase\nSource\n\n\nUppercase Conversion\n :: String -\n String\n\n\nConverts a string to uppercase.\n\n\nStrings::toUppercase('asdf'); // 'ASDF'\n\n\n\n\n\n\ntrim\nSource\n\n\nTrim Whitespace\n :: String -\n String\n\n\nRemoves all leading and trailing whitespace from a string. Defers to\nPHP trim.\n\n\nStrings::trim(' asdf '); // 'asdf'", 
            "title": "Strings"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Strings/#chompsource", 
            "text": "Two-Sided Chomp  :: String -  String  Removes the specified substring from both ends of the target string. Unlike PHP's\ntrim function, the substring to chomp is not a character mask -- rather it is a full\nsubstring. This function is case sensitive.  Strings::chomp('a', 'abccba'); // 'bccb'\nStrings::chomp('ab', 'abccba'); // 'abccba'\nStrings::chomp('A', 'abccba'); // 'abccba'", 
            "title": "chompSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Strings/#concatsource", 
            "text": "String Concatenation  :: String -  String -  String  Concatenates the first argument to the second argument, provided both arguments\nare strings. Defers to the PHP built-in concatenation.  Strings::concat('as', 'df'); // 'dfas'\nStrings::concat('World', $concat('ello', 'H')); // 'HelloWorld'", 
            "title": "concatSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Strings/#joinsource", 
            "text": "String Joining  :: String -  [String] -  String  Joins an array of strings together with a given delimiter. Works similarly\nto PHP  implode . The inverse of  split .  Strings::join(' ', ['Hello', 'World']); // 'Hello World'\nStrings::join('', ['a', 's', 'd', 'f']); // 'asdf'", 
            "title": "joinSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Strings/#lchompsource", 
            "text": "Left Chomp  :: String -  String  Removes the specified substring from the left end of the target string. Unlike PHP's\ntrim function, the substring to chomp is not a character mask -- rather it is a full\nsubstring. This function is case sensitive.  Strings::lchomp('He', 'Hello World'); // 'llo World'\nStrings::lchomp('Hi', 'Hello World'); // 'Hello World'\nStrings::lchomp('he', 'Hello World'); // 'Hello World'", 
            "title": "lchompSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Strings/#rchompsource", 
            "text": "Right Chomp  :: String -  String  Removes the specified substring from the right end of the target string. Unlike PHP's\ntrim function, the substring to chomp is not a character mask -- rather it is a full\nsubstring. This function is case sensitive.  Strings::rchomp('ld', 'Hello World'); // 'Hello Wor'\nStrings::rchomp('li', 'Hello World'); // 'Hello World'\nStrings::rchomp('LD', 'Hello World'); // 'Hello World'", 
            "title": "rchompSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Strings/#replacesource", 
            "text": "String Replace  :: String -  String -  String  Replace all occurrences of the search string with the replacement string.  Strings::replace('test', 'passes', 'this test']); // 'this passes'", 
            "title": "replaceSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Strings/#splitsource", 
            "text": "String Splitting  :: String -  String -  [String]  Split a string into parts based on a delimiter. Operates similar to php  explode ,\nbut is more consistent. Can split on empty delimiters, and trims out empty strings\nafter exploding.  Strings::split('-', 'Hello-World'); // ['Hello', 'World']\nStrings::split('', 'asdf'); // ['a', 's', 'd', 'f']\nStrings::split('-', 'foo-bar-'); ['foo', 'bar']", 
            "title": "splitSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Strings/#startswithsource", 
            "text": "Substring Match  :: String -  String -  Bool  Determines if a string starts with a specific substring. Returns true if the string\nmatches the substring at its start, otherwise false.  Strings::startsWith('as', 'asdf'); true\nStrings::startsWith('foo', 'barfoo'); false", 
            "title": "startsWithSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Strings/#tolowercasesource", 
            "text": "Lowercase Conversion  :: String -  String  Converts a string to lowercase.  Strings::toLowercase('ASdf'); // 'asdf'", 
            "title": "toLowercaseSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Strings/#touppercasesource", 
            "text": "Uppercase Conversion  :: String -  String  Converts a string to uppercase.  Strings::toUppercase('asdf'); // 'ASDF'", 
            "title": "toUppercaseSource"
        }, 
        {
            "location": "/auto-generate/Vector/Lib/Strings/#trimsource", 
            "text": "Trim Whitespace  :: String -  String  Removes all leading and trailing whitespace from a string. Defers to\nPHP trim.  Strings::trim(' asdf '); // 'asdf'", 
            "title": "trimSource"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Applicative/", 
            "text": "apply\nSource\n\n\n____ :: No type given for this function.\n\n\nNo examples given for this function.---\n\n\nliftA2\nSource\n\n\n____ :: No type given for this function.\n\n\nNo examples given for this function.---\n\n\nliftA3\nSource\n\n\n____ :: No type given for this function.\n\n\nNo examples given for this function.---\n\n\npure\nSource\n\n\n____ :: No type given for this function.\n\n\nNo examples given for this function.---", 
            "title": "Applicative"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Applicative/#applysource", 
            "text": "____ :: No type given for this function.  No examples given for this function.---", 
            "title": "applySource"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Applicative/#lifta2source", 
            "text": "____ :: No type given for this function.  No examples given for this function.---", 
            "title": "liftA2Source"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Applicative/#lifta3source", 
            "text": "____ :: No type given for this function.  No examples given for this function.---", 
            "title": "liftA3Source"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Applicative/#puresource", 
            "text": "____ :: No type given for this function.  No examples given for this function.---", 
            "title": "pureSource"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Functor/", 
            "text": "extract\nSource\n\n\n____ :: No type given for this function.\n\n\nNo examples given for this function.---\n\n\nfmap\nSource\n\n\n____ :: No type given for this function.\n\n\nNo examples given for this function.---", 
            "title": "Functor"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Functor/#extractsource", 
            "text": "____ :: No type given for this function.  No examples given for this function.---", 
            "title": "extractSource"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Functor/#fmapsource", 
            "text": "____ :: No type given for this function.  No examples given for this function.---", 
            "title": "fmapSource"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Lens/", 
            "text": "indexLens\n\n\nThis function is currently missing documentation.\n\n\n\n\nindexLensSafe\n\n\nThis function is currently missing documentation.\n\n\n\n\nkeLens\n\n\nThis function is currently missing documentation.\n\n\n\n\noverL\nSource\n\n\nOver\n :: No type given for this function.\n\n\nPerform an operation over the focus of a lens. Returns the entire object\nas passed in, but with the given function run over a portion of it. Is similar to composing\na set and a get operation all at once.\n\n\n$myLens = Lens::indexLens('a');\nLens::overL($myLens, Math::add(1), ['a' =\n 1]; // ['a' =\n 2]\n\n\n\n\n\n\npathLens\n\n\nThis function is currently missing documentation.\n\n\n\n\npathLensSafe\n\n\nThis function is currently missing documentation.\n\n\n\n\npathPropLens\n\n\nThis function is currently missing documentation.\n\n\n\n\npathPropLensSafe\n\n\nThis function is currently missing documentation.\n\n\n\n\npropLens\n\n\nThis function is currently missing documentation.\n\n\n\n\npropLensSafe\n\n\nThis function is currently missing documentation.\n\n\n\n\nsetL\n\n\nThis function is currently missing documentation.\n\n\n\n\nviewL\nSource\n\n\nView\n :: No type given for this function.\n\n\nView an object or array through a lens. Simply applies your lens - the\nbehavior of this function will vary slightly depending on the particular\nlens that you're using.\n\n\n$myLens = Lens::indexLens('a');\nLens::viewL($myLens, ['a' =\n 'b']); // b", 
            "title": "Lens"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Lens/#indexlens", 
            "text": "This function is currently missing documentation.", 
            "title": "indexLens"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Lens/#indexlenssafe", 
            "text": "This function is currently missing documentation.", 
            "title": "indexLensSafe"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Lens/#kelens", 
            "text": "This function is currently missing documentation.", 
            "title": "keLens"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Lens/#overlsource", 
            "text": "Over  :: No type given for this function.  Perform an operation over the focus of a lens. Returns the entire object\nas passed in, but with the given function run over a portion of it. Is similar to composing\na set and a get operation all at once.  $myLens = Lens::indexLens('a');\nLens::overL($myLens, Math::add(1), ['a' =  1]; // ['a' =  2]", 
            "title": "overLSource"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Lens/#pathlens", 
            "text": "This function is currently missing documentation.", 
            "title": "pathLens"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Lens/#pathlenssafe", 
            "text": "This function is currently missing documentation.", 
            "title": "pathLensSafe"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Lens/#pathproplens", 
            "text": "This function is currently missing documentation.", 
            "title": "pathPropLens"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Lens/#pathproplenssafe", 
            "text": "This function is currently missing documentation.", 
            "title": "pathPropLensSafe"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Lens/#proplens", 
            "text": "This function is currently missing documentation.", 
            "title": "propLens"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Lens/#proplenssafe", 
            "text": "This function is currently missing documentation.", 
            "title": "propLensSafe"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Lens/#setl", 
            "text": "This function is currently missing documentation.", 
            "title": "setL"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Lens/#viewlsource", 
            "text": "View  :: No type given for this function.  View an object or array through a lens. Simply applies your lens - the\nbehavior of this function will vary slightly depending on the particular\nlens that you're using.  $myLens = Lens::indexLens('a');\nLens::viewL($myLens, ['a' =  'b']); // b", 
            "title": "viewLSource"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Monad/", 
            "text": "bind\n\n\nThis function is currently missing documentation.\n\n\n\n\nkleisliCompose\n\n\nThis function is currently missing documentation.", 
            "title": "Monad"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Monad/#bind", 
            "text": "This function is currently missing documentation.", 
            "title": "bind"
        }, 
        {
            "location": "/auto-generate/Vector/Control/Monad/#kleislicompose", 
            "text": "This function is currently missing documentation.", 
            "title": "kleisliCompose"
        }
    ]
}